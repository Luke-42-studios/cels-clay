---
phase: 01-build-system-clay-initialization
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - modules/cels-clay/src/clay_engine.c
  - CMakeLists.txt (CELS root -- add cels-clay submodule entry)
autonomous: true

must_haves:
  truths:
    - "Clay_Engine_use() initializes Clay successfully -- Clay_Initialize returns a non-NULL context"
    - "Clay arena is allocated with at least Clay_MinMemorySize() bytes"
    - "Clay errors (duplicate IDs, capacity exceeded) print descriptive messages to stderr"
    - "Arena memory is freed on process exit via atexit handler"
    - "The full project compiles with cels-clay included (no duplicate symbols, no undefined references)"
  artifacts:
    - path: "modules/cels-clay/src/clay_engine.c"
      provides: "Module implementation: _CEL_DefineModule body, arena init, error handler, cleanup"
      contains: "_CEL_DefineModule(Clay_Engine)"
      min_lines: 40
    - path: "CMakeLists.txt"
      provides: "CELS root CMake updated with cels-clay add_subdirectory"
      contains: "add_subdirectory(modules/cels-clay)"
  key_links:
    - from: "src/clay_engine.c"
      to: "clay.h"
      via: "Clay_Initialize, Clay_MinMemorySize, Clay_CreateArenaWithCapacityAndMemory"
      pattern: "Clay_Initialize"
    - from: "src/clay_engine.c"
      to: "clay_engine.h"
      via: "includes module header for Clay_EngineConfig type"
      pattern: "#include.*clay_engine\\.h"
    - from: "src/clay_engine.c"
      to: "atexit"
      via: "registers clay_cleanup to free arena memory"
      pattern: "atexit\\(clay_cleanup\\)"
    - from: "CELS root CMakeLists.txt"
      to: "modules/cels-clay/CMakeLists.txt"
      via: "add_subdirectory"
      pattern: "add_subdirectory.*cels-clay"
---

<objective>
Implement Clay initialization, arena management, error handler, and cleanup inside the _CEL_DefineModule(Clay_Engine) body. Then wire cels-clay into the CELS root CMakeLists.txt so the full project compiles.

Purpose: After this plan, Clay is fully initialized and ready for layout calls. The module startup sequence (arena alloc -> Clay_Initialize -> error handler) runs when a consumer calls Clay_Engine_use(). This is the last piece before Phase 2 can build layout logic on top.
Output: Working clay_engine.c with module init + CELS root integration. Full project compiles.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-build-system-clay-initialization/01-CONTEXT.md
@.planning/phases/01-build-system-clay-initialization/01-RESEARCH.md
@.planning/phases/01-build-system-clay-initialization/01-01-SUMMARY.md

Reference patterns:
@/home/cachy/workspaces/libs/cels/modules/cels-ncurses/src/tui_engine.c
@/home/cachy/workspaces/libs/cels/modules/cels-ncurses/src/window/tui_window.c (atexit pattern, lines 58-63)
</context>

<tasks>

<task type="auto">
  <name>Task 1: clay_engine.c -- Module implementation with arena init, error handler, cleanup</name>
  <files>modules/cels-clay/src/clay_engine.c</files>
  <action>
Create clay_engine.c following the cels-ncurses/tui_engine.c pattern. This file implements the Clay_Engine module.

**Static state:**
- `static Clay_EngineConfig g_clay_config = {0};` -- stored by Clay_Engine_use, read by init body
- `static void* g_clay_arena_memory = NULL;` -- original malloc pointer, needed for free (Clay aligns arena.memory to 64-byte boundary, so arena.memory != malloc result)

**Error handler function** (`static void clay_error_handler(Clay_ErrorData error)`):
- Switch on `error.errorType` to produce a human-readable type string for the prefix:
  - CLAY_ERROR_TYPE_TEXT_MEASUREMENT_FUNCTION_NOT_PROVIDED -> "text measurement function not provided"
  - CLAY_ERROR_TYPE_ARENA_CAPACITY_EXCEEDED -> "arena capacity exceeded"
  - CLAY_ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED -> "elements capacity exceeded"
  - CLAY_ERROR_TYPE_TEXT_MEASUREMENT_CAPACITY_EXCEEDED -> "text measurement capacity exceeded"
  - CLAY_ERROR_TYPE_DUPLICATE_ID -> "duplicate ID"
  - CLAY_ERROR_TYPE_FLOATING_CONTAINER_PARENT_NOT_FOUND -> "floating container parent not found"
  - CLAY_ERROR_TYPE_PERCENTAGE_OVER_1 -> "percentage over 1"
  - CLAY_ERROR_TYPE_INTERNAL_ERROR -> "internal error"
  - CLAY_ERROR_TYPE_UNBALANCED_OPEN_CLOSE -> "unbalanced open/close"
  - default -> "unknown"
- Print to stderr: `fprintf(stderr, "[cels-clay] %s: %.*s\n", type_str, error.errorText.length, error.errorText.chars);`
- IMPORTANT: Clay's errorText is a Clay_String (chars + length), NOT null-terminated. Use %.*s format specifier with length.
- Never abort. Log and continue -- let the app keep running even with layout issues.

**Cleanup function** (`static void clay_cleanup(void)`):
- If g_clay_arena_memory is non-NULL, free it and set to NULL
- This is registered via atexit() during module init (same pattern as cels-ncurses cleanup_endwin)
- CRITICAL: Free g_clay_arena_memory (the original malloc pointer), NOT arena.memory (which Clay has cache-line aligned and offset from the original)

**Module definition** (`_CEL_DefineModule(Clay_Engine)`):
1. Calculate arena size:
   - `uint32_t min_memory = Clay_MinMemorySize();`
   - If g_clay_config.arena_size > 0 AND >= min_memory, use g_clay_config.arena_size
   - If g_clay_config.arena_size > 0 AND < min_memory, print warning to stderr and clamp to min_memory
   - If g_clay_config.arena_size == 0 (default), use min_memory
2. Allocate arena memory:
   - `g_clay_arena_memory = malloc(arena_size);`
   - `Clay_Arena arena = Clay_CreateArenaWithCapacityAndMemory(arena_size, g_clay_arena_memory);`
3. Initialize Clay:
   - `Clay_Initialize(arena, (Clay_Dimensions){0, 0}, (Clay_ErrorHandler){ .errorHandlerFunction = clay_error_handler });`
   - Initial dimensions are 0,0 -- Phase 2's layout system will call Clay_SetLayoutDimensions each frame with terminal size
   - Store the returned Clay_Context* in a static variable for future multi-context support (but don't use it in Phase 1)
4. Register cleanup: `atexit(clay_cleanup);`

**Public function** (`void Clay_Engine_use(Clay_EngineConfig config)`):
- Store config: `g_clay_config = config;`
- Trigger init: `Clay_Engine_init();` (idempotent via _CEL_DefineModule guard)

**Includes:**
- `#include "cels-clay/clay_engine.h"` -- module header (for Clay_EngineConfig, extern declarations)
- `#include "clay.h"` -- Clay API (for Clay_Initialize, Clay_MinMemorySize, etc.)
- `<stdlib.h>` -- for malloc, free, atexit
- `<stdio.h>` -- for fprintf, stderr
- `<stdint.h>` -- for uint32_t (if not already via clay.h)

NOTE: This file does NOT define CLAY_IMPLEMENTATION. That's in clay_impl.c. This file just uses Clay's API through the declarations in clay.h.
  </action>
  <verify>
Read clay_engine.c and verify:
- `_CEL_DefineModule(Clay_Engine)` is present
- Clay_MinMemorySize() is called to determine arena size
- g_clay_arena_memory stores the malloc result (separate from arena.memory)
- Clay_Initialize is called with arena, zero dimensions, and error handler
- atexit(clay_cleanup) is registered
- clay_error_handler uses %.*s for Clay_String (not %s)
- Clay_Engine_use stores config and calls Clay_Engine_init
- Does NOT define CLAY_IMPLEMENTATION
  </verify>
  <done>clay_engine.c implements the full module init sequence: arena alloc, Clay_Initialize, error handler, atexit cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Wire cels-clay into CELS root CMakeLists.txt + verify full build</name>
  <files>CMakeLists.txt (CELS root: /home/cachy/workspaces/libs/cels/CMakeLists.txt)</files>
  <action>
Add cels-clay as a submodule in the CELS root CMakeLists.txt, following the exact pattern used for cels-ncurses (lines 132-137).

In the "Provider Modules" section, AFTER the cels-ncurses block, add:

```cmake
# cels-clay module (Clay layout engine integration)
if(NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/modules/cels-clay/CMakeLists.txt")
    message(FATAL_ERROR "cels-clay module not found at modules/cels-clay/. "
                        "Run: git submodule update --init modules/cels-clay")
endif()
add_subdirectory(modules/cels-clay)
```

Then verify the full project compiles:
```bash
cd /home/cachy/workspaces/libs/cels/build
cmake -DCLAY_SOURCE_DIR=/home/cachy/workspaces/libs/clay .. && make -j$(nproc)
```

Use CLAY_SOURCE_DIR to point to the local Clay checkout at /home/cachy/workspaces/libs/clay so we don't need to fetch from GitHub during development.

If there are compile errors, fix them. Common issues:
- Missing includes in clay_engine.c
- Type mismatches between Clay_EngineConfig fields and Clay API types
- Clay_String format specifier issues (must use %.*s with .length, not %s)

The build should complete with zero errors. There may be warnings from Clay itself (unused variables, etc.) -- those are acceptable. cels-clay code should compile warning-free.
  </action>
  <verify>
```bash
cd /home/cachy/workspaces/libs/cels/build && cmake -DCLAY_SOURCE_DIR=/home/cachy/workspaces/libs/clay .. && make -j$(nproc) 2>&1 | tail -20
```
- CMake configure succeeds (no "not found" errors)
- Build succeeds (exit code 0)
- No duplicate symbol errors (proves CLAY_IMPLEMENTATION is in exactly one TU)
- No undefined reference to Clay_* functions (proves clay_impl.c is being compiled)

Optionally, verify the existing tests still pass:
```bash
cd /home/cachy/workspaces/libs/cels/build && ctest --output-on-failure
```
  </verify>
  <done>CELS root CMakeLists.txt includes cels-clay, full project compiles successfully with Clay integrated, no duplicate symbols or undefined references</done>
</task>

</tasks>

<verification>
After both tasks, verify the complete Phase 1 success criteria:

1. **Consumer can link cels-clay:** The CELS root CMakeLists.txt has `add_subdirectory(modules/cels-clay)` and the full project builds.
2. **No duplicate symbols:** Only clay_impl.c defines CLAY_IMPLEMENTATION. Build succeeds without "multiple definition" linker errors.
3. **Clay arena is allocated:** clay_engine.c calls Clay_MinMemorySize() and malloc to allocate arena. Clay_Initialize succeeds.
4. **Error handler is wired:** clay_error_handler is registered via Clay_ErrorHandler struct in Clay_Initialize call.
5. **Cleanup is registered:** atexit(clay_cleanup) frees the arena memory on exit.

To test Clay initialization actually works (beyond just compiling), a future plan or the Phase 2 layout system will call Clay_Engine_use() and exercise the init path. For Phase 1, a successful compile with no linker errors proves the wiring is correct.
</verification>

<success_criteria>
1. clay_engine.c contains _CEL_DefineModule(Clay_Engine) with arena init, error handler, atexit cleanup
2. Arena size defaults to Clay_MinMemorySize() with configurable override via Clay_EngineConfig.arena_size
3. Error handler prints all Clay error types to stderr with descriptive prefixes using %.*s for Clay_String
4. Original malloc pointer is stored separately from arena.memory for correct free()
5. CELS root CMakeLists.txt has add_subdirectory(modules/cels-clay) matching cels-ncurses pattern
6. Full project compiles: `cmake .. && make` succeeds with zero errors
7. Existing tests still pass (no regressions from adding cels-clay)
</success_criteria>

<output>
After completion, create `.planning/phases/01-build-system-clay-initialization/01-02-SUMMARY.md`
</output>
