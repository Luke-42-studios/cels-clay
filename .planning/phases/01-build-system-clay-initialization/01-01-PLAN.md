---
phase: 01-build-system-clay-initialization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - modules/cels-clay/CMakeLists.txt
  - modules/cels-clay/include/cels-clay/clay_engine.h
  - modules/cels-clay/src/clay_impl.c
autonomous: true

must_haves:
  truths:
    - "A consumer project can add_subdirectory(modules/cels-clay) and get Clay headers + cels-clay sources available"
    - "The cels::clay alias target exists and links against cels"
    - "CLAY_IMPLEMENTATION is defined in exactly one translation unit (clay_impl.c)"
    - "Clay.h include path is exposed so consumers can use CLAY() macros directly"
  artifacts:
    - path: "modules/cels-clay/CMakeLists.txt"
      provides: "INTERFACE library target with FetchContent for Clay"
      contains: "add_library(cels-clay INTERFACE)"
    - path: "modules/cels-clay/include/cels-clay/clay_engine.h"
      provides: "Public module header declaring Clay_Engine, config struct, use function"
      contains: "Clay_Engine_use"
    - path: "modules/cels-clay/src/clay_impl.c"
      provides: "Single translation unit defining CLAY_IMPLEMENTATION"
      contains: "CLAY_IMPLEMENTATION"
  key_links:
    - from: "CMakeLists.txt"
      to: "clay_SOURCE_DIR"
      via: "FetchContent_Populate or CLAY_SOURCE_DIR override"
      pattern: "FetchContent_Populate\\(clay\\)"
    - from: "CMakeLists.txt"
      to: "cels"
      via: "target_link_libraries INTERFACE"
      pattern: "target_link_libraries.*cels"
    - from: "CMakeLists.txt"
      to: "clay_impl.c"
      via: "target_sources INTERFACE"
      pattern: "target_sources.*clay_impl\\.c"
---

<objective>
Create the CMake build system for cels-clay: FetchContent to fetch Clay from GitHub, INTERFACE library target matching the cels-ncurses pattern, public header declaring the module API, and the dedicated CLAY_IMPLEMENTATION translation unit.

Purpose: This is the foundation that every other plan builds on. Without a working CMake target and Clay headers available, no Clay code can compile.
Output: CMakeLists.txt, clay_engine.h, clay_impl.c -- a linkable cels-clay target that compiles when add_subdirectory'd.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-build-system-clay-initialization/01-CONTEXT.md
@.planning/phases/01-build-system-clay-initialization/01-RESEARCH.md

Reference patterns:
@/home/cachy/workspaces/libs/cels/modules/cels-ncurses/CMakeLists.txt
@/home/cachy/workspaces/libs/cels/modules/cels-ncurses/include/cels-ncurses/tui_engine.h
@/home/cachy/workspaces/libs/cels/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: CMakeLists.txt with FetchContent Populate + INTERFACE library</name>
  <files>modules/cels-clay/CMakeLists.txt</files>
  <action>
Create CMakeLists.txt following the cels-ncurses pattern exactly, with Clay-specific additions.

Structure:
1. cmake_minimum_required(VERSION 3.21) -- matches CELS root
2. FetchContent section:
   - `set(CLAY_SOURCE_DIR "" CACHE PATH "Path to local Clay source (overrides FetchContent)")` for local dev override
   - If CLAY_SOURCE_DIR is set, use that path directly as clay_SOURCE_DIR
   - Otherwise, FetchContent_Declare clay from `https://github.com/nicbarker/clay.git` at tag `v0.14`
   - Use FetchContent_GetProperties + FetchContent_Populate (NOT MakeAvailable) because Clay's CMakeLists.txt builds example executables requiring raylib/SDL/etc. Populate only fetches the source.
3. INTERFACE library:
   - `add_library(cels-clay INTERFACE)`
   - `add_library(cels::clay ALIAS cels-clay)` -- namespaced alias matching cels::cels convention
   - `target_sources(cels-clay INTERFACE ...)` listing:
     - `${CMAKE_CURRENT_SOURCE_DIR}/src/clay_impl.c`
     - `${CMAKE_CURRENT_SOURCE_DIR}/src/clay_engine.c`
   - `target_include_directories(cels-clay INTERFACE ...)` exposing:
     - `${CMAKE_CURRENT_SOURCE_DIR}/include` -- for cels-clay headers
     - `${clay_SOURCE_DIR}` -- for clay.h (consumers need CLAY() macros)
   - `target_link_libraries(cels-clay INTERFACE cels)` -- depends on cels

IMPORTANT: Do NOT use FetchContent_MakeAvailable -- it calls add_subdirectory on Clay's CMakeLists.txt which tries to build ALL example executables (raylib, SDL, sokol, etc.) and will fail.

The `if(NOT TARGET cels)` guard with a placeholder FetchContent block for CELS is NOT needed for Phase 1 -- the consumer project (CELS root) already provides the cels target via add_subdirectory. Add a comment noting this can be added later for standalone use.
  </action>
  <verify>
Read the created CMakeLists.txt and verify:
- FetchContent_Populate is used (not MakeAvailable)
- CLAY_SOURCE_DIR cache variable exists for local override
- INTERFACE library with alias cels::clay
- Both source files listed in target_sources
- Both include dirs (module + clay) in target_include_directories
- Links cels via INTERFACE
  </verify>
  <done>CMakeLists.txt exists with FetchContent Populate pattern, INTERFACE library, and all targets properly configured</done>
</task>

<task type="auto">
  <name>Task 2: Public header (clay_engine.h) + CLAY_IMPLEMENTATION TU (clay_impl.c)</name>
  <files>
    modules/cels-clay/include/cels-clay/clay_engine.h
    modules/cels-clay/src/clay_impl.c
  </files>
  <action>
Create two files:

**clay_engine.h** -- Module public header. Follow the cels-ncurses/tui_engine.h pattern:
1. Header guard: `CELS_CLAY_ENGINE_H`
2. Include `<cels/cels.h>` for cels_entity_t and module macros
3. Define `Clay_EngineConfig` struct with:
   - `uint32_t arena_size` -- override arena capacity (0 = use Clay_MinMemorySize default)
4. Declare module externals:
   - `extern cels_entity_t Clay_Engine;`
   - `extern void Clay_Engine_init(void);`
   - `extern void Clay_Engine_use(Clay_EngineConfig config);`
5. Add doc comments explaining usage: consumer calls `Clay_Engine_use((Clay_EngineConfig){...})` inside a CEL_Build block to initialize Clay

Keep it minimal for Phase 1. Future phases will add fields to Clay_EngineConfig (e.g., root composition callback, measure text function). The header does NOT include clay.h -- that's an implementation detail. Consumers who need CLAY() macros will include clay.h separately (it's on the include path from CMakeLists.txt).

**clay_impl.c** -- Dedicated translation unit for Clay implementation:
1. `#define CLAY_IMPLEMENTATION`
2. `#include "clay.h"`
3. Nothing else. This file exists solely to instantiate Clay's implementation symbols in exactly one TU.

Add a comment at the top of clay_impl.c explaining WHY this file exists (Clay is a single-header library; defining CLAY_IMPLEMENTATION in more than one .c file causes duplicate symbol linker errors).
  </action>
  <verify>
Read both files and verify:
- clay_engine.h has include guard, cels.h include, Clay_EngineConfig struct, extern declarations
- clay_engine.h does NOT include clay.h
- clay_impl.c defines CLAY_IMPLEMENTATION before including clay.h
- clay_impl.c contains nothing else (no function definitions, no other includes beyond clay.h)
  </verify>
  <done>clay_engine.h declares the module API, clay_impl.c is the single CLAY_IMPLEMENTATION translation unit</done>
</task>

</tasks>

<verification>
After both tasks, the cels-clay module directory should have:
```
modules/cels-clay/
  CMakeLists.txt
  include/cels-clay/clay_engine.h
  src/clay_impl.c
  src/clay_engine.c  (listed in CMake but NOT created yet -- Plan 01-02 creates it)
```

Note: The build will NOT compile yet because src/clay_engine.c doesn't exist. That's expected -- Plan 01-02 creates the implementation file. The CMakeLists.txt is complete and correct; it just needs the missing source file.

To verify the CMake structure is parseable (even if build fails):
```bash
# From CELS root build directory:
cmake -DCLAY_SOURCE_DIR=/home/cachy/workspaces/libs/clay ../.. 2>&1 | head -20
```
This should show CMake processing cels-clay without FetchContent errors (since we're using local override). It may error on missing clay_engine.c which is expected.
</verification>

<success_criteria>
1. CMakeLists.txt uses FetchContent_Populate (not MakeAvailable) to fetch Clay v0.14
2. CLAY_SOURCE_DIR cache variable allows local Clay checkout override
3. cels-clay is an INTERFACE library with cels::clay alias
4. Clay include path is PUBLIC (consumers can `#include "clay.h"`)
5. clay_engine.h declares Clay_Engine module with config struct
6. clay_impl.c defines CLAY_IMPLEMENTATION in exactly one file
7. No source file includes clay.h with CLAY_IMPLEMENTATION except clay_impl.c
</success_criteria>

<output>
After completion, create `.planning/phases/01-build-system-clay-initialization/01-01-SUMMARY.md`
</output>
