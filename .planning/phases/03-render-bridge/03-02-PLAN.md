---
phase: 03-render-bridge
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - include/cels-clay/clay_engine.h
  - src/clay_engine.c
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Clay_Engine_use(&(ClayEngineConfig){0}) initializes Clay arena, layout system, AND render bridge in one call"
    - "clay_layout_use() initializes only the layout subsystem (without render bridge)"
    - "clay_render_use() initializes only the render bridge (without layout)"
    - "ClayEngineConfig accepts arena_size, error_handler override, and initial layout dimensions"
    - "CEL_DefineModule(Clay_Engine) bundles layout + render systems and registers them in correct order"
    - "clay_render.c is compiled as part of the INTERFACE library sources"
  artifacts:
    - path: "include/cels-clay/clay_engine.h"
      provides: "ClayEngineConfig with pointer API, composable sub-module declarations"
      contains: "Clay_Engine_use"
    - path: "src/clay_engine.c"
      provides: "Module definition calling layout + render init, composable wrappers"
      contains: "_cel_clay_render_init"
    - path: "CMakeLists.txt"
      provides: "clay_render.c added to INTERFACE library sources"
      contains: "clay_render.c"
  key_links:
    - from: "src/clay_engine.c"
      to: "src/clay_render.c"
      via: "_cel_clay_render_init() + _cel_clay_render_system_register()"
      pattern: "_cel_clay_render_init|_cel_clay_render_system_register"
    - from: "src/clay_engine.c"
      to: "src/clay_layout.c"
      via: "_cel_clay_layout_init() + _cel_clay_layout_system_register()"
      pattern: "_cel_clay_layout_init|_cel_clay_layout_system_register"
    - from: "include/cels-clay/clay_engine.h"
      to: "public API"
      via: "Clay_Engine_use(const ClayEngineConfig*) pointer signature"
      pattern: "Clay_Engine_use.*const ClayEngineConfig\\*"
---

<objective>
Restructure the Clay_Engine module to integrate the render bridge from Plan 01, change to pointer-based config API, and add composable sub-module functions.

Purpose: Completes CORE-02 (CEL_DefineModule facade). After this, Clay_Engine_use() initializes the full pipeline (arena + layout + render bridge), and advanced users can pick individual pieces with clay_layout_use()/clay_render_use().

Output: Updated clay_engine.h and clay_engine.c, updated CMakeLists.txt.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/API-DESIGN.md
@.planning/phases/03-render-bridge/03-CONTEXT.md
@.planning/phases/03-render-bridge/03-RESEARCH.md

@include/cels-clay/clay_engine.h
@src/clay_engine.c
@CMakeLists.txt

# Prior plan output
@.planning/phases/03-render-bridge/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand config struct and change to pointer-based API</name>
  <files>
    include/cels-clay/clay_engine.h
  </files>
  <action>
Update `include/cels-clay/clay_engine.h`:

1. Add `#include <stdbool.h>` for the error handler override field.

2. Add forward declaration: `typedef struct Clay_ErrorData Clay_ErrorData;` (needed for the error handler function pointer type if clay.h is not included by engine header -- but clay_layout.h includes clay.h which is already available. Check if clay.h is included transitively. If not, add `#include "clay.h"`).

3. Expand `ClayEngineConfig` struct:
   ```c
   typedef struct ClayEngineConfig {
       uint32_t arena_size;        /* Override arena capacity in bytes (0 = default) */
       float initial_width;        /* Initial layout width (0 = not set until ClaySurface) */
       float initial_height;       /* Initial layout height (0 = not set until ClaySurface) */
   } ClayEngineConfig;
   ```
   Note: Do NOT add error_handler to the config -- the internal error handler is sufficient and adding a Clay_ErrorData dependency to the public header creates unnecessary coupling. The error handler is an internal concern.

4. Change `Clay_Engine_use` signature from by-value to by-pointer:
   ```c
   extern void Clay_Engine_use(const ClayEngineConfig* config);
   ```

5. Add composable sub-module declarations:
   ```c
   /* Composable sub-modules (for advanced users who want individual pieces) */
   extern void clay_layout_use(void);   /* Layout system only */
   extern void clay_render_use(void);   /* Render bridge only */
   ```

6. Add include for `clay_render.h` so consumers get the full API from just `clay_engine.h`:
   ```c
   #include "cels-clay/clay_render.h"
   ```
   Place this after the cels include but before the config struct.
  </action>
  <verify>
1. Header compiles: `gcc -fsyntax-only -I include -I build/_deps/clay-src -I ../../include include/cels-clay/clay_engine.h` (or equivalent via cmake).
2. Signature is `const ClayEngineConfig*` (pointer, not value).
3. `clay_layout_use` and `clay_render_use` are declared.
  </verify>
  <done>
- ClayEngineConfig has arena_size, initial_width, initial_height fields
- Clay_Engine_use takes const ClayEngineConfig* pointer
- clay_layout_use() and clay_render_use() are declared
- clay_render.h is included transitively from clay_engine.h
  </done>
</task>

<task type="auto">
  <name>Task 2: Restructure module init, add composable wrappers, update CMake</name>
  <files>
    src/clay_engine.c
    CMakeLists.txt
  </files>
  <action>
**Part A: Update src/clay_engine.c**

1. Add include for the new render header:
   ```c
   #include "cels-clay/clay_render.h"
   ```

2. Update `_CEL_DefineModule(Clay_Engine)` body to integrate render bridge. The new body should:
   a. Calculate arena size (existing logic, unchanged)
   b. Allocate arena memory (existing logic, unchanged)
   c. Initialize Clay with initial dimensions from config:
      ```c
      g_clay_context = Clay_Initialize(
          arena,
          (Clay_Dimensions){
              .width = g_clay_config.initial_width,
              .height = g_clay_config.initial_height
          },
          (Clay_ErrorHandler){ .errorHandlerFunction = clay_error_handler }
      );
      ```
   d. Initialize layout subsystem: `_cel_clay_layout_init();`
   e. Initialize render bridge (creates singleton, registers feature): `_cel_clay_render_init();`
   f. Register systems in correct order (dispatch BEFORE providers):
      ```c
      _cel_clay_layout_system_register();
      _cel_clay_render_system_register();
      ```
   g. Register cleanup: `atexit(clay_cleanup);`

3. Update `Clay_Engine_use` to pointer-based API:
   ```c
   void Clay_Engine_use(const ClayEngineConfig* config) {
       if (config) {
           g_clay_config = *config;
       }
       Clay_Engine_init();  /* idempotent via _CEL_DefineModule guard */
   }
   ```

4. Add composable sub-module wrapper functions:
   ```c
   void clay_layout_use(void) {
       _cel_clay_layout_init();
       _cel_clay_layout_system_register();
   }

   void clay_render_use(void) {
       _cel_clay_render_init();
       _cel_clay_render_system_register();
   }
   ```
   These are for advanced users who want individual pieces without the full Clay_Engine_use. Note: they do NOT allocate the Clay arena or call Clay_Initialize -- the user is responsible for that when using composable pieces.

**Part B: Update CMakeLists.txt**

Add `src/clay_render.c` to the INTERFACE library sources. Find the existing `target_sources` command that lists `clay_engine.c`, `clay_impl.c`, `clay_layout.c` and add `clay_render.c` to it. Also add the new header to the headers list if one exists.

Look at the current CMakeLists.txt pattern and follow it exactly. The file is an INTERFACE library, so sources are added with `INTERFACE` visibility.
  </action>
  <verify>
1. `cmake -B build -S . -DCMAKE_BUILD_TYPE=Debug` succeeds (reconfigure to pick up new source file).
2. `cmake --build build` compiles with no errors.
3. Verify `Clay_Engine_use` takes pointer: `grep "const ClayEngineConfig\*" src/clay_engine.c`
4. Verify render init is called: `grep "_cel_clay_render_init" src/clay_engine.c`
5. Verify render system registered: `grep "_cel_clay_render_system_register" src/clay_engine.c`
6. Verify CMakeLists.txt includes clay_render.c: `grep "clay_render" CMakeLists.txt`
7. Verify composable wrappers exist: `grep "clay_layout_use\|clay_render_use" src/clay_engine.c`
  </verify>
  <done>
- clay_engine.c calls _cel_clay_render_init() and _cel_clay_render_system_register() in module init body
- Layout system registers BEFORE render dispatch (correct ordering for flecs)
- Clay_Engine_use takes const pointer, copies to static, calls idempotent init
- clay_layout_use() and clay_render_use() work as standalone initializers
- CMakeLists.txt compiles clay_render.c as part of the INTERFACE library
- Full build succeeds with zero errors
  </done>
</task>

</tasks>

<verification>
1. Full reconfigure + build: `cmake -B build -S . && cmake --build build` succeeds
2. Phase 3 success criteria check:
   a. "ClayRenderable Feature is defined and a Provider callback receives the Clay_RenderCommandArray each frame" -- grep confirms _CEL_DefineFeature in clay_render.c, ClayRenderableData struct contains render_commands field
   b. "Render dispatch runs at OnStore phase" -- grep confirms EcsOnStore in system registration
   c. "CEL_DefineModule(Clay_Engine) bundles layout + render systems" -- grep confirms both _init and _system_register calls in clay_engine.c
   d. "Clay_Engine_use() initializes the full module in one call" -- function calls Clay_Engine_init() which is idempotent
3. Requirement coverage:
   - CORE-02: CEL_DefineModule facade with composable sub-modules
   - PIPE-01: ClayRenderable Feature defined
   - PIPE-02: Provider callback pattern dispatches render commands
   - PIPE-04: Render dispatch at OnStore (after PreStore layout)
</verification>

<success_criteria>
- Clay_Engine_use(&(ClayEngineConfig){0}) compiles and initializes everything
- Composable sub-modules (clay_layout_use, clay_render_use) are callable independently
- Module init order is: arena -> layout init -> render init -> layout system register -> render dispatch register -> cleanup
- CMakeLists.txt includes clay_render.c
- Full build compiles with zero errors and zero warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-render-bridge/03-02-SUMMARY.md`
</output>
