---
phase: 03-render-bridge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/cels-clay/clay_render.h
  - src/clay_render.c
  - include/cels-clay/clay_layout.h
  - src/clay_layout.c
autonomous: true

must_haves:
  truths:
    - "ClayRenderable Feature is defined at file scope with CELS_Phase_OnStore"
    - "A singleton ClayRenderTarget entity exists with ClayRenderableData component"
    - "A render dispatch system at OnStore updates the singleton each frame with current render commands"
    - "A backend can register via _CEL_Provides(Backend, ClayRenderable, ClayRenderableData, callback)"
    - "An advanced user can call cel_clay_get_render_commands() to get the array directly"
    - "Layout dimensions from the most recent layout pass are available in ClayRenderableData"
  artifacts:
    - path: "include/cels-clay/clay_render.h"
      provides: "ClayRenderableData struct, component ID, getter API, render init declarations"
      contains: "ClayRenderableData"
    - path: "src/clay_render.c"
      provides: "Feature definition, component registration, singleton entity, dispatch system"
      contains: "_CEL_DefineFeature(ClayRenderable"
    - path: "include/cels-clay/clay_layout.h"
      provides: "Layout dimension getter declaration"
      contains: "_cel_clay_get_layout_dimensions"
    - path: "src/clay_layout.c"
      provides: "Layout dimension storage during layout pass"
      contains: "g_last_layout_dimensions"
  key_links:
    - from: "src/clay_render.c"
      to: "src/clay_layout.c"
      via: "_cel_clay_get_render_commands() and _cel_clay_get_layout_dimensions()"
      pattern: "_cel_clay_get_render_commands|_cel_clay_get_layout_dimensions"
    - from: "src/clay_render.c"
      to: "singleton entity"
      via: "ecs_set_id updating ClayRenderableData each frame"
      pattern: "ecs_set_id.*g_render_target.*ClayRenderableDataID"
    - from: "src/clay_render.c"
      to: "CELS Feature/Provider"
      via: "_CEL_DefineFeature + _CEL_Feature at file scope and in init"
      pattern: "_CEL_DefineFeature.*ClayRenderable"
---

<objective>
Create the render bridge subsystem: ClayRenderable Feature, ClayRenderableData component, singleton render target entity, and render dispatch system at OnStore phase.

Purpose: This bridges the layout system's output (Clay_RenderCommandArray) to renderer backends via CELS Feature/Provider pattern. Backends register with _CEL_Provides and receive render commands each frame.

Output: Two new files (clay_render.h, clay_render.c) plus additions to clay_layout.h/c for dimension tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/API-DESIGN.md
@.planning/phases/03-render-bridge/03-CONTEXT.md
@.planning/phases/03-render-bridge/03-RESEARCH.md

@include/cels-clay/clay_layout.h
@src/clay_layout.c
</context>

<tasks>

<task type="auto">
  <name>Task 1: Layout dimension tracking + render bridge header and implementation</name>
  <files>
    include/cels-clay/clay_layout.h
    src/clay_layout.c
    include/cels-clay/clay_render.h
    src/clay_render.c
  </files>
  <action>
**Part A: Add layout dimension storage to clay_layout.c and declaration to clay_layout.h**

In `src/clay_layout.c`:
1. Add a static global `g_last_layout_dimensions` of type `Clay_Dimensions` initialized to `{0, 0}`.
2. In `ClayLayoutSystem_callback`, after `Clay_SetLayoutDimensions(...)`, store the dimensions: `g_last_layout_dimensions = (Clay_Dimensions){ .width = config->width, .height = config->height };`
3. Add a public function `_cel_clay_get_layout_dimensions(void)` that returns `g_last_layout_dimensions`.

In `include/cels-clay/clay_layout.h`:
4. Add the declaration near the other internal function declarations (near `_cel_clay_get_render_commands`):
   `extern Clay_Dimensions _cel_clay_get_layout_dimensions(void);`

**Part B: Create clay_render.h**

Create `include/cels-clay/clay_render.h` with:

1. Include guard `CELS_CLAY_RENDER_H`
2. Includes: `<cels/cels.h>`, `"clay.h"`, `<stdbool.h>`, `<stdint.h>`
3. `ClayRenderableData` struct:
   ```c
   typedef struct ClayRenderableData {
       Clay_RenderCommandArray render_commands;
       float layout_width;
       float layout_height;
       uint32_t frame_number;
       float delta_time;
       bool dirty;
   } ClayRenderableData;
   ```
4. Extern declarations:
   - `extern cels_entity_t ClayRenderableDataID;`
   - `extern cels_entity_t ClayRenderableData_ensure(void);`
5. Public getter API:
   - `extern Clay_RenderCommandArray cel_clay_get_render_commands(void);`
6. Internal lifecycle declarations (for clay_engine.c to call):
   - `extern void _cel_clay_render_init(void);`
   - `extern void _cel_clay_render_system_register(void);`

**Part C: Create clay_render.c**

Create `src/clay_render.c` with:

1. Includes: `"cels-clay/clay_render.h"`, `"cels-clay/clay_layout.h"`, `"clay.h"`, `<cels/cels.h>`, `<flecs.h>`, `<stdio.h>`, `<stdbool.h>`

2. Feature definition at file scope (NOT inside a function):
   ```c
   _CEL_DefineFeature(ClayRenderable, .phase = CELS_Phase_OnStore, .priority = 0);
   ```

3. Component registration:
   ```c
   cels_entity_t ClayRenderableDataID = 0;

   cels_entity_t ClayRenderableData_ensure(void) {
       if (ClayRenderableDataID == 0) {
           ClayRenderableDataID = cels_component_register("ClayRenderableData",
               sizeof(ClayRenderableData), CELS_ALIGNOF(ClayRenderableData));
       }
       return ClayRenderableDataID;
   }
   ```

4. Static state:
   ```c
   static cels_entity_t g_render_target = 0;
   static uint32_t g_frame_number = 0;
   ```

5. Render dispatch system callback:
   ```c
   static void ClayRenderDispatch_callback(ecs_iter_t* it) {
       (void)it;
       g_frame_number++;

       ecs_world_t* world = cels_get_world(cels_get_context());
       Clay_RenderCommandArray commands = _cel_clay_get_render_commands();
       Clay_Dimensions dims = _cel_clay_get_layout_dimensions();

       ClayRenderableData data = {
           .render_commands = commands,
           .layout_width = dims.width,
           .layout_height = dims.height,
           .frame_number = g_frame_number,
           .delta_time = it->delta_time,
           .dirty = (commands.length > 0)
       };

       ecs_set_id(world, g_render_target, ClayRenderableDataID,
                  sizeof(ClayRenderableData), &data);
   }
   ```

6. Public getter:
   ```c
   Clay_RenderCommandArray cel_clay_get_render_commands(void) {
       return _cel_clay_get_render_commands();
   }
   ```

7. Init function (called from clay_engine.c during module init):
   ```c
   void _cel_clay_render_init(void) {
       ClayRenderableData_ensure();

       ecs_world_t* world = cels_get_world(cels_get_context());

       g_render_target = ecs_entity_init(world, &(ecs_entity_desc_t){
           .name = "ClayRenderTarget"
       });

       ClayRenderableData initial = {0};
       ecs_set_id(world, g_render_target, ClayRenderableDataID,
                  sizeof(ClayRenderableData), &initial);

       _CEL_Feature(ClayRenderableData, ClayRenderable);
   }
   ```

8. System registration function (called from clay_engine.c BEFORE any _CEL_Provides calls):
   ```c
   void _cel_clay_render_system_register(void) {
       ecs_world_t* world = cels_get_world(cels_get_context());

       ecs_system_desc_t sys_desc = {0};
       ecs_entity_desc_t entity_desc = {0};
       entity_desc.name = "ClayRenderDispatch";

       ecs_id_t phase_ids[3] = {
           ecs_pair(EcsDependsOn, EcsOnStore),
           EcsOnStore,
           0
       };
       entity_desc.add = phase_ids;

       sys_desc.entity = ecs_entity_init(world, &entity_desc);
       sys_desc.callback = ClayRenderDispatch_callback;

       ecs_system_init(world, &sys_desc);
   }
   ```

**Important patterns to follow:**
- `_CEL_DefineFeature` at file scope (creates static variables). `_CEL_Feature` inside init function (NOT file scope).
- Match `cels-ncurses/src/renderer/tui_renderer.c` 3-step pattern exactly.
- System registration uses the same flecs `ecs_system_init` pattern as `_cel_clay_layout_system_register` in `clay_layout.c`.
- The `(void)it` suppresses unused parameter warning but `it->delta_time` is still accessed -- so do NOT cast `(void)it` if you use `it->delta_time`. Instead just use `it` directly.
  </action>
  <verify>
1. Run `cmake --build build` from the module root -- should compile with no errors or warnings.
2. Verify `clay_render.c` contains `_CEL_DefineFeature(ClayRenderable` at file scope.
3. Verify `clay_render.c` contains `_CEL_Feature(ClayRenderableData, ClayRenderable)` inside `_cel_clay_render_init` function.
4. Verify `clay_layout.c` stores dimensions and exposes `_cel_clay_get_layout_dimensions`.
5. Verify no duplicate symbol errors from the new file.
  </verify>
  <done>
- clay_render.h defines ClayRenderableData struct with render_commands, dimensions, frame_number, delta_time, dirty fields
- clay_render.c has _CEL_DefineFeature at file scope, component registration, singleton entity creation, dispatch system at OnStore
- clay_layout.c stores layout dimensions and exposes them via getter
- All new functions are declared in headers and compile without errors
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build` compiles successfully with clay_render.c included
2. grep confirms `_CEL_DefineFeature(ClayRenderable` exists in clay_render.c
3. grep confirms `_cel_clay_render_init` and `_cel_clay_render_system_register` are declared in clay_render.h
4. grep confirms `_cel_clay_get_layout_dimensions` is declared in clay_layout.h and implemented in clay_layout.c
5. No function is called at file scope that should be in an init function
</verification>

<success_criteria>
- ClayRenderable Feature defined at OnStore phase
- ClayRenderableData component registered with CELS
- Singleton render target entity created during init
- Render dispatch system registered at OnStore that updates singleton each frame
- Layout dimensions tracked and available to render dispatch
- Public getter API (cel_clay_get_render_commands) available for advanced users
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-render-bridge/03-01-SUMMARY.md`
</output>
