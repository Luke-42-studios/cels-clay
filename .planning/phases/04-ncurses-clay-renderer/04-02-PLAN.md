---
phase: 04-ncurses-clay-renderer
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - modules/cels-clay/include/cels-clay/clay_ncurses_renderer.h
  - modules/cels-clay/src/clay_ncurses_renderer.c
autonomous: true

must_haves:
  truths:
    - "Vim-style j/k scroll one line, Ctrl-U/Ctrl-D scroll half-page, G scrolls to bottom"
    - "gg multi-key sequence scrolls to top (g followed by g within same or next frame)"
    - "Arrow keys and Page Up/Down also scroll via CELS_Input fields"
    - "Scroll deltas are passed to Clay_UpdateScrollContainers each frame"
    - "Scroll handling is exposed via a public function the app calls before layout"
  artifacts:
    - path: "modules/cels-clay/include/cels-clay/clay_ncurses_renderer.h"
      provides: "clay_ncurses_handle_scroll_input declaration"
      contains: "clay_ncurses_handle_scroll_input"
    - path: "modules/cels-clay/src/clay_ncurses_renderer.c"
      provides: "Scroll input handling with Vim bindings and multi-key gg"
      contains: "Clay_UpdateScrollContainers"
  key_links:
    - from: "clay_ncurses_renderer.c"
      to: "Clay_UpdateScrollContainers"
      via: "scroll delta computed from CELS_Input raw_key and navigation keys"
      pattern: "Clay_UpdateScrollContainers"
    - from: "clay_ncurses_renderer.c"
      to: "CELS_Input"
      via: "raw_key for j/k/G/Ctrl-U/Ctrl-D, key_page_up/key_page_down, axis_left"
      pattern: "input->raw_key"
---

<objective>
Add scroll container keyboard navigation to the ncurses Clay renderer, mapping Vim-style key bindings to Clay_UpdateScrollContainers.

Purpose: Scroll containers are a core Clay feature for terminal UIs (long content lists, log viewers, documentation). Without keyboard-driven scrolling, scroll containers are unusable in a keyboard-only terminal environment.

Output: Public function for handling scroll input from CELS_Input, with Vim-style j/k/Ctrl-U/Ctrl-D/G/gg bindings plus arrow keys and Page Up/Down.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ncurses-clay-renderer/04-CONTEXT.md
@.planning/phases/04-ncurses-clay-renderer/04-RESEARCH.md
@.planning/phases/04-ncurses-clay-renderer/04-01-SUMMARY.md

Key source files:
- modules/cels-clay/include/cels-clay/clay_ncurses_renderer.h (add declaration)
- modules/cels-clay/src/clay_ncurses_renderer.c (add implementation)
- Clay clay.h: Clay_UpdateScrollContainers(bool enableDragScrolling, Clay_Vector2 scrollDelta, float deltaTime)
- CELS cels.h: CELS_Input struct (raw_key, has_raw_key, key_page_up, key_page_down, axis_left)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scroll input handler with Vim-style bindings</name>
  <files>
    modules/cels-clay/include/cels-clay/clay_ncurses_renderer.h
    modules/cels-clay/src/clay_ncurses_renderer.c
  </files>
  <action>
Add scroll container keyboard navigation.

**Header addition (clay_ncurses_renderer.h):**
- Add declaration: `void clay_ncurses_handle_scroll_input(const CELS_Input* input, float delta_time);`
- This function is meant to be called by the app each frame BEFORE Clay_BeginLayout
- Add `#include <cels/cels.h>` to the header for CELS_Input type (cels.h is already a dependency of cels-clay)

**Implementation (clay_ncurses_renderer.c):**

1. **Static state for multi-key sequences:**
   - `static int g_prev_raw_key = 0;` -- tracks previous frame's raw key for gg detection

2. **clay_ncurses_handle_scroll_input(const CELS_Input* input, float delta_time):**
   - Initialize scroll_delta = {0, 0}
   - Guard: if input == NULL, call Clay_UpdateScrollContainers(false, (Clay_Vector2){0,0}, delta_time) and return

   - **Vim key bindings (from input->raw_key when input->has_raw_key):**
     - 'j': scroll_delta.y = 1.0f (one line down)
     - 'k': scroll_delta.y = -1.0f (one line up)
     - 4 (Ctrl-D, ASCII EOT): scroll_delta.y = 12.0f (half page down)
     - 21 (Ctrl-U, ASCII NAK): scroll_delta.y = -12.0f (half page up)
     - 'G': scroll_delta.y = 10000.0f (scroll to bottom -- large value, Clay clamps)
     - 'g': check g_prev_raw_key -- if prev was also 'g', scroll_delta.y = -10000.0f (scroll to top)

   - **CELS_Input navigation keys:**
     - input->key_page_down: scroll_delta.y = 12.0f
     - input->key_page_up: scroll_delta.y = -12.0f

   - **Arrow keys via axis:**
     - input->axis_left[1] > 0.5f: scroll_delta.y = 1.0f (down)
     - input->axis_left[1] < -0.5f: scroll_delta.y = -1.0f (up)

   - **Update prev_key state:**
     - If input->has_raw_key: g_prev_raw_key = input->raw_key
     - Else: g_prev_raw_key = 0 (reset if no key this frame)

   - **Call Clay:** Clay_UpdateScrollContainers(false, scroll_delta, delta_time)
     - First arg (enableDragScrolling) is false -- no mouse in terminal v1

   **Priority order:** Vim keys take precedence (checked first). If a Vim key sets scroll_delta, the navigation keys and axis checks still run but later assignments overwrite. This is fine since only one key is typically pressed per frame. However, to prevent double-scrolling (e.g., 'j' AND axis_left both triggering), structure the code so that Vim raw_key handling is checked first, and axis/page keys only apply if scroll_delta is still zero. Use a simple `if (scroll_delta.y == 0.0f)` guard before the axis/page section.

   **Do NOT register this as an ECS system.** This is a plain function the app calls. The app controls when and how scroll input is processed (e.g., only when a scrollable container has focus). The CONTEXT.md decision says "App manages focus -- renderer does NOT own which container receives scroll input."
  </action>
  <verify>
1. Header contains clay_ncurses_handle_scroll_input declaration
2. Implementation handles: j/k (single line), Ctrl-U/Ctrl-D (half page), G (bottom), gg (top), Page Up/Down, arrow keys
3. Multi-key gg state uses static prev_key variable
4. Clay_UpdateScrollContainers is called with computed scroll delta
5. Function does NOT register as an ECS system (app calls it explicitly)
6. `cmake -B build -S /home/cachy/workspaces/libs/cels -DCELS_BUILD_TOOLS=ON -DCELS_DEBUG=ON 2>&1` configures without error
  </verify>
  <done>
Scroll input handler maps Vim-style key bindings (j/k, Ctrl-U/Ctrl-D, G, gg) plus Page Up/Down and arrow keys to Clay_UpdateScrollContainers deltas. Multi-key gg sequence tracked via static state. Function is app-callable, not an ECS system. Requirement REND-08 addressed.
  </done>
</task>

</tasks>

<verification>
1. All 8 REND requirements now have implementations (REND-01 through REND-07 in Plan 01, REND-08 in this plan)
2. Scroll handler compiles with cels-ncurses conditional guard (same as renderer)
3. The gg multi-key detection correctly uses previous frame state
4. Clay_UpdateScrollContainers receives appropriate deltas for all supported key bindings
</verification>

<success_criteria>
- clay_ncurses_handle_scroll_input is declared in header and implemented in source
- Vim bindings: j=+1, k=-1, Ctrl-D=+12, Ctrl-U=-12, G=+10000, gg=-10000
- Page Up/Down and arrow keys provide fallback navigation
- Multi-key gg requires two consecutive 'g' presses
- App calls this function explicitly (not auto-registered as ECS system)
- REND-08 (scroll container keyboard navigation) is complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-ncurses-clay-renderer/04-02-SUMMARY.md`
</output>
