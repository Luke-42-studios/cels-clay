---
phase: 02-layout-system-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/clay_layout.c
  - src/clay_engine.c
autonomous: true

must_haves:
  truths:
    - "ClaySurface entity stores width/height and drives the layout pass"
    - "Layout system runs at PreStore phase each frame"
    - "Entity tree is walked depth-first, parent-before-child"
    - "Layout functions execute between Clay_BeginLayout and Clay_EndLayout"
    - "CEL_Clay_Children emits child entity layouts at the call site"
    - "Non-Clay entities are transparent pass-throughs in the tree walk"
    - "Clay_SetLayoutDimensions is called before BeginLayout with ClaySurface dimensions"
    - "Frame arena resets before each layout pass"
  artifacts:
    - path: "src/clay_layout.c"
      provides: "Complete layout system: tree walk, ClaySurface system, CEL_Clay_Children"
      contains: "clay_walk_entity"
    - path: "src/clay_engine.c"
      provides: "Module init wires layout subsystem init and system registration"
      contains: "_cel_clay_layout_init"
  key_links:
    - from: "src/clay_engine.c"
      to: "src/clay_layout.c"
      via: "_cel_clay_layout_init and _cel_clay_layout_system_register calls in module init"
      pattern: "_cel_clay_layout_"
    - from: "src/clay_layout.c ClayLayoutSystem"
      to: "Clay_BeginLayout/Clay_EndLayout"
      via: "system callback brackets all tree walk calls"
      pattern: "Clay_BeginLayout.*Clay_EndLayout"
    - from: "src/clay_layout.c clay_walk_entity"
      to: "ClayUI.layout_fn"
      via: "tree walk calls stored function pointers"
      pattern: "layout->layout_fn"
    - from: "src/clay_layout.c _cel_clay_emit_children"
      to: "clay_walk_children"
      via: "CEL_Clay_Children macro delegates to child walk"
      pattern: "clay_walk_children"
---

<objective>
Implement the layout system core: PreStore layout system, depth-first entity tree walk, CEL_Clay_Children child emission, and wire into Clay_Engine module init.

Purpose: This is the heart of cels-clay. The layout system coordinates Clay's BeginLayout/EndLayout pass by walking the CELS entity tree and calling stored layout functions. ClaySurface owns the layout dimensions. After this plan, the full layout pipeline works: ClaySurface sets dimensions, system calls BeginLayout, tree walk executes layout functions (which call CLAY() via CEL_Clay), system calls EndLayout.

Output: Complete `clay_layout.c` (stubs from Plan 01 replaced with real implementations), updated `clay_engine.c` (module init wires layout subsystem).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-layout-system-core/02-CONTEXT.md
@.planning/phases/02-layout-system-core/02-RESEARCH.md
@.planning/phases/02-layout-system-core/02-01-PLAN.md
@.planning/API-DESIGN.md
@include/cels-clay/clay_layout.h
@include/cels-clay/clay_engine.h
@src/clay_layout.c
@src/clay_engine.c
</context>

<tasks>

<task type="auto">
  <name>Task 1: Entity tree walk + CEL_Clay_Children + layout system</name>
  <files>src/clay_layout.c</files>
  <action>
Replace the stubs in `clay_layout.c` (created by Plan 01) with full implementations. This adds the tree walk, the PreStore system, and the CEL_Clay_Children implementation.

You will need `#include <flecs.h>` for direct flecs API calls (ecs_children, ecs_get_id, ecs_system_init, etc.). This is the same pattern used by cels-ncurses (see `modules/cels-ncurses/src/input/tui_input.c`).

**Forward declarations** (add near top of file, after static globals):
```c
static void clay_walk_entity(ecs_world_t* world, ecs_entity_t entity);
static void clay_walk_children(ecs_world_t* world, ecs_entity_t parent);
```

**Entity tree walk** -- depth-first, recursive:

```c
static void clay_walk_entity(ecs_world_t* world, ecs_entity_t entity) {
    const ClayUI* layout = (const ClayUI*)ecs_get_id(
        world, entity, ClayUIID);

    /* Save/restore current entity for nested CEL_Clay_Children calls */
    ecs_entity_t prev_entity = g_layout_current_entity;
    g_layout_current_entity = entity;

    if (layout && layout->layout_fn) {
        /* Entity has a layout function -- call it.
         * The function body contains CEL_Clay() and CEL_Clay_Children() calls.
         * Developer MUST call CEL_Clay_Children() to emit children --
         * children are NOT auto-appended (they'd be outside the CLAY scope). */
        layout->layout_fn(world, entity);
    } else {
        /* No ClayUI component -- transparent pass-through.
         * Walk children directly so Clay children still participate. */
        clay_walk_children(world, entity);
    }

    g_layout_current_entity = prev_entity;
}
```

Note: Component is `ClayUI` / `ClayUIID` (matching API-DESIGN.md, not `ClayLayout`).

**Child iteration** using flecs ecs_children():

```c
static void clay_walk_children(ecs_world_t* world, ecs_entity_t parent) {
    ecs_iter_t it = ecs_children(world, parent);
    while (ecs_children_next(&it)) {
        for (int i = 0; i < it.count; i++) {
            clay_walk_entity(world, it.entities[i]);
        }
    }
}
```

**CEL_Clay_Children implementation** -- replace the stub:

```c
void _cel_clay_emit_children(void) {
    if (!g_layout_pass_active || g_layout_world == NULL) {
        fprintf(stderr, "[cels-clay] CEL_Clay_Children() called outside layout pass\n");
        return;
    }
    clay_walk_children(g_layout_world, g_layout_current_entity);
}
```

**Render command storage:**

```c
static Clay_RenderCommandArray g_last_render_commands = {0};

Clay_RenderCommandArray _cel_clay_get_render_commands(void) {
    return g_last_render_commands;
}
```

**Layout system** -- runs at PreStore phase:

IMPORTANT: Use `cels_get_world(cels_get_context())` (NOT bare `cels_get_world()`). The CELS API requires a context argument: `ecs_world_t* cels_get_world(CELS_Context* ctx)`.

```c
static void ClayLayoutSystem_Run(CELS_Iter* it) {
    (void)it;

    ecs_world_t* world = cels_get_world(cels_get_context());

    /* Find ClaySurface entities by querying for ClaySurfaceConfig */
    ecs_iter_t surface_it = ecs_each_id(world, ClaySurfaceConfigID);
    while (ecs_each_next(&surface_it)) {
        for (int i = 0; i < surface_it.count; i++) {
            ecs_entity_t surface = surface_it.entities[i];
            const ClaySurfaceConfig* config = (const ClaySurfaceConfig*)
                ecs_get_id(world, surface, ClaySurfaceConfigID);
            if (!config) continue;

            /* 1. Set layout dimensions */
            Clay_SetLayoutDimensions((Clay_Dimensions){
                .width = config->width,
                .height = config->height
            });

            /* 2. Reset frame arena for this pass */
            _cel_clay_frame_arena_reset();

            /* 3. Begin layout pass */
            Clay_BeginLayout();
            g_layout_world = world;
            g_layout_pass_active = true;

            /* 4. Walk children of the ClaySurface entity */
            clay_walk_children(world, surface);

            /* 5. End layout pass */
            g_layout_pass_active = false;
            g_layout_world = NULL;
            g_layout_current_entity = 0;

            g_last_render_commands = Clay_EndLayout();
        }
    }
}
```

IMPORTANT: Verify `ecs_each_id` exists in the flecs version bundled with CELS. If not, use `ecs_query` or direct filter iteration. Check `cels-ncurses/src/input/tui_input.c` for the pattern used there (it uses `ecs_each_id`).

**System registration** -- replace the stub. Use direct `ecs_system_init` (same pattern as cels-ncurses `TUI_Input_use`), NOT `cels_system_register_with_lifecycle`:

```c
void _cel_clay_layout_system_register(void) {
    ecs_world_t* world = cels_get_world(cels_get_context());

    ecs_system_desc_t sys_desc = {0};
    ecs_entity_desc_t entity_desc = {0};
    entity_desc.name = "ClayLayoutSystem";

    /* Register at PreStore phase using flecs phase pairs */
    ecs_id_t phase_ids[3] = {
        ecs_pair(EcsDependsOn, EcsPreStore),
        EcsPreStore,
        0
    };
    entity_desc.add = phase_ids;

    sys_desc.entity = ecs_entity_init(world, &entity_desc);
    sys_desc.callback = ClayLayoutSystem_Run;

    ecs_system_init(world, &sys_desc);
}
```

Why direct `ecs_system_init` instead of `cels_system_register_with_lifecycle`:
- This system has zero component requirements (it manually queries entities)
- `cels_system_register_with_lifecycle` may not handle zero-component systems correctly
- cels-ncurses uses this exact same direct pattern for its input system (see `tui_input.c` line 149-161)
- This is a module-internal system, not a user-facing one

IMPORTANT: Verify that `EcsPreStore` is the correct flecs phase constant. CELS maps `CELS_Phase_PreStore` to a flecs phase. Check how CELS defines its phases -- look for `EcsPreStore` in the flecs headers or `CELS_Phase_PreStore` mapping in cels.cpp. If the constant name differs, use the correct one. The cels-ncurses input system uses `EcsOnLoad` as a reference.

**Build verification:** After implementing, build and verify no errors.
  </action>
  <verify>
1. `clay_walk_entity` and `clay_walk_children` functions exist in clay_layout.c
2. Uses `ClayUI` / `ClayUIID` (not ClayLayout / ClayLayoutID)
3. `_cel_clay_emit_children` is no longer a stub -- calls `clay_walk_children`
4. `ClayLayoutSystem_Run` uses `cels_get_world(cels_get_context())` (with context arg)
5. `_cel_clay_layout_system_register` uses direct `ecs_system_init` (not cels_system_register_with_lifecycle)
6. `g_layout_pass_active` is set to true during layout pass, false outside
7. Build succeeds: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | tail -20`
  </verify>
  <done>
Tree walk implemented: depth-first recursive walk using ecs_children(), transparent pass-through for non-ClayUI entities, save/restore of current entity for nested calls. CEL_Clay_Children delegates to clay_walk_children. Layout system registered at PreStore via direct ecs_system_init (matching cels-ncurses pattern): finds ClaySurface entities, sets dimensions, resets arena, BeginLayout, tree walk, EndLayout, stores render commands. Uses cels_get_world(cels_get_context()) correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire layout subsystem into Clay_Engine module init</name>
  <files>src/clay_engine.c</files>
  <action>
Update `clay_engine.c` to call the layout subsystem init and system registration during module startup.

**Add include:**
```c
#include "cels-clay/clay_layout.h"
```

**Update _CEL_DefineModule(Clay_Engine) body** -- add two calls AFTER Clay_Initialize:

```c
_CEL_DefineModule(Clay_Engine) {
    /* ... existing arena allocation and Clay_Initialize code ... */

    /* 5. Initialize layout subsystem (frame arena, text measurement, components) */
    _cel_clay_layout_init();

    /* 6. Register layout system at PreStore phase */
    _cel_clay_layout_system_register();

    /* existing atexit(clay_cleanup) stays */
}
```

The `_cel_clay_layout_init()` call MUST come AFTER `Clay_Initialize` because:
- `Clay_SetMeasureTextFunction` requires Clay to be initialized
- Component registration requires CELS world to exist (it does -- module init runs during CEL_Build)

The `_cel_clay_layout_system_register()` call registers the PreStore system.

**Update clay_cleanup** -- add layout cleanup:

```c
static void clay_cleanup(void) {
    _cel_clay_layout_cleanup();  /* Free frame arena */
    if (g_clay_arena_memory != NULL) {
        free(g_clay_arena_memory);
        g_clay_arena_memory = NULL;
    }
}
```

Layout cleanup BEFORE arena free, since layout cleanup only frees its own frame arena (independent of Clay's arena).

**Build and verify:**
Build the project. Verify no compile errors, no undefined references to `_cel_clay_layout_init`, `_cel_clay_layout_cleanup`, `_cel_clay_layout_system_register`.
  </action>
  <verify>
1. `clay_engine.c` includes `cels-clay/clay_layout.h`
2. `_CEL_DefineModule(Clay_Engine)` body calls `_cel_clay_layout_init()` and `_cel_clay_layout_system_register()`
3. `clay_cleanup()` calls `_cel_clay_layout_cleanup()` before freeing Clay arena
4. Build succeeds with no undefined references
5. Existing functionality preserved (Clay init, error handler, arena alloc unchanged)
  </verify>
  <done>
Clay_Engine module init wires layout subsystem: calls _cel_clay_layout_init (frame arena + text measurement + component registration) after Clay_Initialize, registers ClayLayoutSystem at PreStore phase, cleanup frees frame arena before Clay arena. Full layout pipeline is now initialized when consumer calls Clay_Engine_use().
  </done>
</task>

</tasks>

<verification>
1. Tree walk functions exist and are recursive (clay_walk_entity calls clay_walk_children, which calls clay_walk_entity for each child)
2. Uses ClayUI / ClayUIID throughout (not ClayLayout)
3. Layout system uses cels_get_world(cels_get_context()) -- not bare cels_get_world()
4. System registration uses direct ecs_system_init (matching cels-ncurses pattern)
5. Layout system queries ClaySurfaceConfig entities and runs Begin/End pass
6. Clay_SetLayoutDimensions called before BeginLayout with surface config dimensions
7. Frame arena reset before each layout pass
8. g_layout_pass_active is true only between BeginLayout and EndLayout
9. CEL_Clay_Children emits children at the call site (not auto-appended)
10. Non-Clay entities are transparent (children still walked)
11. Module init calls layout init after Clay_Initialize
12. Cleanup frees frame arena
13. Project builds and all existing tests pass
</verification>

<success_criteria>
- Entity tree walked depth-first using ecs_children in creation order
- Parent layout function opens CLAY scope, CEL_Clay_Children emits children inside, scope closes
- Non-ClayUI entities skipped but their children still participate (transparent pass-through)
- Layout system at PreStore: SetDimensions -> arena reset -> BeginLayout -> tree walk -> EndLayout
- ClaySurface entities found by querying ClaySurfaceConfig component
- Render commands stored after EndLayout (accessible for Phase 3)
- Module init wires layout init + system registration + cleanup
- cels_get_world called with cels_get_context() argument
- System registered via ecs_system_init (same pattern as cels-ncurses)
- Project compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-layout-system-core/02-02-SUMMARY.md`
</output>
