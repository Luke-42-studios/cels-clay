---
phase: 02-layout-system-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/clay_layout.c
  - src/clay_engine.c
autonomous: true

must_haves:
  truths:
    - "ClaySurface entity stores width/height and drives the layout pass"
    - "Layout system runs at PreStore phase each frame"
    - "Entity tree is walked depth-first, parent-before-child"
    - "Layout functions execute between Clay_BeginLayout and Clay_EndLayout"
    - "CEL_Clay_Children emits child entity layouts at the call site"
    - "Non-Clay entities are transparent pass-throughs in the tree walk"
    - "Clay_SetLayoutDimensions is called before BeginLayout with ClaySurface dimensions"
    - "Frame arena resets before each layout pass"
  artifacts:
    - path: "src/clay_layout.c"
      provides: "Complete layout system: tree walk, ClaySurface system, CEL_Clay_Children"
      contains: "clay_walk_entity"
    - path: "src/clay_engine.c"
      provides: "Module init wires layout subsystem init and system registration"
      contains: "_cel_clay_layout_init"
  key_links:
    - from: "src/clay_engine.c"
      to: "src/clay_layout.c"
      via: "_cel_clay_layout_init and _cel_clay_layout_system_register calls in module init"
      pattern: "_cel_clay_layout_"
    - from: "src/clay_layout.c ClayLayoutSystem"
      to: "Clay_BeginLayout/Clay_EndLayout"
      via: "system callback brackets all tree walk calls"
      pattern: "Clay_BeginLayout.*Clay_EndLayout"
    - from: "src/clay_layout.c clay_walk_entity"
      to: "ClayLayout.layout_fn"
      via: "tree walk calls stored function pointers"
      pattern: "layout->layout_fn"
    - from: "src/clay_layout.c _cel_clay_emit_children"
      to: "clay_walk_children"
      via: "CEL_Clay_Children macro delegates to child walk"
      pattern: "clay_walk_children"
---

<objective>
Implement the layout system core: ClaySurface composition entity, PreStore layout system, depth-first entity tree walk, and CEL_Clay_Children child emission.

Purpose: This is the heart of cels-clay. The layout system coordinates Clay's BeginLayout/EndLayout pass by walking the CELS entity tree and calling stored layout functions. ClaySurface owns the layout dimensions. After this plan, the full layout pipeline works: ClaySurface sets dimensions, system calls BeginLayout, tree walk executes layout functions (which call CLAY() via CEL_Clay), system calls EndLayout.

Output: Complete `clay_layout.c` (stubs from Plan 01 replaced with real implementations), updated `clay_engine.c` (module init wires layout subsystem).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-layout-system-core/02-CONTEXT.md
@.planning/phases/02-layout-system-core/02-RESEARCH.md
@.planning/phases/02-layout-system-core/02-01-PLAN.md
@include/cels-clay/clay_layout.h
@include/cels-clay/clay_engine.h
@src/clay_layout.c
@src/clay_engine.c
</context>

<tasks>

<task type="auto">
  <name>Task 1: Entity tree walk + CEL_Clay_Children + layout system</name>
  <files>src/clay_layout.c</files>
  <action>
Replace the stubs in `clay_layout.c` (created by Plan 01) with full implementations. This adds the tree walk, the PreStore system, and the CEL_Clay_Children implementation.

**Forward declarations** (add near top of file, after static globals):
```c
static void clay_walk_entity(ecs_world_t* world, ecs_entity_t entity);
static void clay_walk_children(ecs_world_t* world, ecs_entity_t parent);
```

**Entity tree walk** -- depth-first, recursive:

```c
/* Walk a single entity in the layout tree.
 * If entity has ClayLayout component, call its layout_fn.
 * If not, transparent pass-through -- walk children directly. */
static void clay_walk_entity(ecs_world_t* world, ecs_entity_t entity) {
    const ClayLayout* layout = (const ClayLayout*)ecs_get_id(
        world, entity, ClayLayoutID);

    /* Save/restore current entity for nested CEL_Clay_Children calls */
    ecs_entity_t prev_entity = g_layout_current_entity;
    g_layout_current_entity = entity;

    if (layout && layout->layout_fn) {
        /* Entity has a layout function -- call it.
         * The function body contains CEL_Clay() and CEL_Clay_Children() calls.
         * If it does NOT call CEL_Clay_Children(), children are emitted
         * AFTER the function returns (implicit children at end). */
        layout->layout_fn(world, entity);
    } else {
        /* No layout component -- transparent pass-through.
         * Walk children directly so Clay children still participate. */
        clay_walk_children(world, entity);
    }

    g_layout_current_entity = prev_entity;
}
```

IMPORTANT design decision about implicit vs explicit children:

When a layout function calls CEL_Clay_Children(), children are emitted at that point. If the layout function does NOT call CEL_Clay_Children(), children must still be emitted. The simplest approach: the tree walk does NOT auto-emit children after calling layout_fn. Instead, the developer MUST call CEL_Clay_Children() inside their layout function if they have children. If they forget, children are silently skipped (consistent with Clay's manual nesting model).

This is the correct behavior because:
- Layout functions that open a CLAY scope need children INSIDE that scope
- Auto-appending children AFTER the function would place them OUTSIDE the CLAY scope (wrong nesting)
- The developer controls placement with CEL_Clay_Children()

**Child iteration** using flecs ecs_children():

```c
/* Walk all children of a parent entity, in creation order. */
static void clay_walk_children(ecs_world_t* world, ecs_entity_t parent) {
    ecs_iter_t it = ecs_children(world, parent);
    while (ecs_children_next(&it)) {
        for (int i = 0; i < it.count; i++) {
            clay_walk_entity(world, it.entities[i]);
        }
    }
}
```

**CEL_Clay_Children implementation** -- replace the stub:

```c
void _cel_clay_emit_children(void) {
    if (!g_layout_pass_active || g_layout_world == NULL) {
        fprintf(stderr, "[cels-clay] CEL_Clay_Children() called outside layout pass\n");
        return;
    }
    clay_walk_children(g_layout_world, g_layout_current_entity);
}
```

**ClaySurface root entity tracking:**

```c
/* Track the ClaySurface root entity. Set during module init or first ClaySurface creation.
 * The layout system queries entities with ClaySurfaceConfig to find surfaces. */
static ecs_entity_t g_clay_surface_entity = 0;
```

**Layout system** -- runs at PreStore phase:

The system finds ClaySurface entities (entities with ClaySurfaceConfig component), and for each:
1. Reads ClaySurfaceConfig to get dimensions
2. Calls Clay_SetLayoutDimensions
3. Resets frame arena
4. Calls Clay_BeginLayout
5. Walks the entity's children (depth-first tree walk)
6. Calls Clay_EndLayout
7. Stores the returned Clay_RenderCommandArray (for Phase 3 render bridge)

```c
/* Store last render command array for Phase 3 render bridge */
static Clay_RenderCommandArray g_last_render_commands = {0};

/* Getter for render commands -- Phase 3 will expose this via Feature/Provider */
Clay_RenderCommandArray _cel_clay_get_render_commands(void) {
    return g_last_render_commands;
}

static void ClayLayoutSystem_Run(CELS_Iter* it) {
    (void)it;  /* System does not iterate components -- it drives the layout pass */

    ecs_world_t* world = cels_get_world();

    /* Find ClaySurface entities by querying for ClaySurfaceConfig */
    ecs_iter_t surface_it = ecs_each_id(world, ClaySurfaceConfigID);
    while (ecs_each_next(&surface_it)) {
        for (int i = 0; i < surface_it.count; i++) {
            ecs_entity_t surface = surface_it.entities[i];
            const ClaySurfaceConfig* config = (const ClaySurfaceConfig*)
                ecs_get_id(world, surface, ClaySurfaceConfigID);
            if (!config) continue;

            /* 1. Set layout dimensions */
            Clay_SetLayoutDimensions((Clay_Dimensions){
                .width = config->width,
                .height = config->height
            });

            /* 2. Reset frame arena for this pass */
            _cel_clay_frame_arena_reset();

            /* 3. Begin layout pass */
            Clay_BeginLayout();
            g_layout_world = world;
            g_layout_pass_active = true;

            /* 4. Walk children of the ClaySurface entity */
            clay_walk_children(world, surface);

            /* 5. End layout pass */
            g_layout_pass_active = false;
            g_layout_world = NULL;
            g_layout_current_entity = 0;

            g_last_render_commands = Clay_EndLayout();
        }
    }
}
```

IMPORTANT: The system uses `ecs_each_id` to find entities with ClaySurfaceConfig. Verify this is the correct flecs API. An alternative is `ecs_query` or `ecs_filter_init`. Check what CELS systems typically use for querying. If `ecs_each_id` doesn't exist, use the equivalent flecs v4 iteration API.

The system iterates ClaySurface entities (there should typically be exactly one). For each, it runs the full layout pass. The tree walk starts from the ClaySurface entity's children (not the surface entity itself -- the surface IS the root container).

**System registration** -- replace the stub:

```c
void _cel_clay_layout_system_register(void) {
    cels_system_register_with_lifecycle(
        "ClayLayoutSystem",
        CELS_Phase_PreStore,
        ClayLayoutSystem_Run,
        NULL,  /* no component requirements -- system drives the pass manually */
        0,     /* component count */
        0      /* no lifecycle -- runs unconditionally */
    );
}
```

Check the `cels_system_register_with_lifecycle` signature from cels.h. It takes: name, phase, callback, component_ids array, component_count, lifecycle entity. Pass NULL/0 for components since this system manually queries entities rather than iterating a component archetype.

**Add the _cel_clay_get_render_commands declaration to clay_layout.h** -- this will be needed by Phase 3 but declaring it now is clean. Add to the header:
```c
extern Clay_RenderCommandArray _cel_clay_get_render_commands(void);
```

Wait -- Plan 01 already wrote clay_layout.h. This plan should NOT modify the header to avoid file conflicts. Instead, add the declaration as a forward declaration at the top of clay_layout.c (it's internal to the module for now). Phase 3 can add it to the header when needed.

Actually, re-reading the files_modified -- this plan only modifies clay_layout.c and clay_engine.c. Do NOT modify clay_layout.h. The `_cel_clay_get_render_commands` function can be declared in a future plan or in a render-bridge header.

**Build verification:** After implementing, build and verify no errors.
  </action>
  <verify>
1. `clay_walk_entity` and `clay_walk_children` functions exist in clay_layout.c
2. `_cel_clay_emit_children` is no longer a stub -- calls `clay_walk_children`
3. `ClayLayoutSystem_Run` exists and brackets tree walk with `Clay_BeginLayout`/`Clay_EndLayout`
4. `_cel_clay_layout_system_register` is no longer a stub -- calls `cels_system_register_with_lifecycle`
5. `g_layout_pass_active` is set to true during layout pass, false outside
6. Build succeeds: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | tail -20`
  </verify>
  <done>
Tree walk implemented: depth-first recursive walk using ecs_children(), transparent pass-through for non-Clay entities, save/restore of current entity for nested calls. CEL_Clay_Children delegates to clay_walk_children. Layout system registered at PreStore: finds ClaySurface entities, sets dimensions, resets arena, BeginLayout, tree walk, EndLayout, stores render commands. System registration uses cels_system_register_with_lifecycle.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire layout subsystem into Clay_Engine module init</name>
  <files>src/clay_engine.c</files>
  <action>
Update `clay_engine.c` to call the layout subsystem init and system registration during module startup.

**Add include:**
```c
#include "cels-clay/clay_layout.h"
```

**Update _CEL_DefineModule(Clay_Engine) body** -- add two calls AFTER Clay_Initialize:

```c
_CEL_DefineModule(Clay_Engine) {
    /* ... existing arena allocation and Clay_Initialize code ... */

    /* 5. Initialize layout subsystem (frame arena, text measurement, components) */
    _cel_clay_layout_init();

    /* 6. Register layout system at PreStore phase */
    _cel_clay_layout_system_register();

    /* existing atexit(clay_cleanup) stays */
}
```

The `_cel_clay_layout_init()` call MUST come AFTER `Clay_Initialize` because:
- `Clay_SetMeasureTextFunction` requires Clay to be initialized
- Component registration requires CELS world to exist (it does -- module init runs during CEL_Build)

The `_cel_clay_layout_system_register()` call registers the PreStore system.

**Update clay_cleanup** -- add layout cleanup:

```c
static void clay_cleanup(void) {
    _cel_clay_layout_cleanup();  /* Free frame arena */
    if (g_clay_arena_memory != NULL) {
        free(g_clay_arena_memory);
        g_clay_arena_memory = NULL;
    }
}
```

Layout cleanup BEFORE arena free, since layout cleanup only frees its own frame arena (independent of Clay's arena).

**Build and verify:**
Build the project. Verify no compile errors, no undefined references to `_cel_clay_layout_init`, `_cel_clay_layout_cleanup`, `_cel_clay_layout_system_register`.
  </action>
  <verify>
1. `clay_engine.c` includes `cels-clay/clay_layout.h`
2. `_CEL_DefineModule(Clay_Engine)` body calls `_cel_clay_layout_init()` and `_cel_clay_layout_system_register()`
3. `clay_cleanup()` calls `_cel_clay_layout_cleanup()` before freeing Clay arena
4. Build succeeds with no undefined references
5. Existing functionality preserved (Clay init, error handler, arena alloc unchanged)
  </verify>
  <done>
Clay_Engine module init wires layout subsystem: calls _cel_clay_layout_init (frame arena + text measurement + component registration) after Clay_Initialize, registers ClayLayoutSystem at PreStore phase, cleanup frees frame arena before Clay arena. Full layout pipeline is now initialized when consumer calls Clay_Engine_use().
  </done>
</task>

</tasks>

<verification>
1. Tree walk functions exist and are recursive (clay_walk_entity calls clay_walk_children, which calls clay_walk_entity for each child)
2. Layout system queries ClaySurfaceConfig entities and runs Begin/End pass
3. Clay_SetLayoutDimensions called before BeginLayout with surface config dimensions
4. Frame arena reset before each layout pass
5. g_layout_pass_active is true only between BeginLayout and EndLayout
6. CEL_Clay_Children emits children at the call site (not auto-appended)
7. Non-Clay entities are transparent (children still walked)
8. Module init calls layout init after Clay_Initialize
9. Cleanup frees frame arena
10. Project builds and all existing tests pass
</verification>

<success_criteria>
- Entity tree walked depth-first using ecs_children in creation order
- Parent layout function opens CLAY scope, CEL_Clay_Children emits children inside, scope closes
- Non-Clay entities skipped but their children still participate (transparent pass-through)
- Layout system at PreStore: SetDimensions -> arena reset -> BeginLayout -> tree walk -> EndLayout
- ClaySurface entities found by querying ClaySurfaceConfig component
- Render commands stored after EndLayout (accessible for Phase 3)
- Module init wires layout init + system registration + cleanup
- Project compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-layout-system-core/02-02-SUMMARY.md`
</output>
