---
phase: 02-layout-system-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/cels-clay/clay_layout.h
  - src/clay_layout.c
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Developer can include clay_layout.h and see CEL_Clay, CEL_Clay_Layout, CEL_Clay_Children, CEL_Clay_Text macros"
    - "Developer can attach a layout function to an entity with CEL_Has(ClayUI, .layout_fn = my_fn)"
    - "Dynamic strings passed to CEL_Clay_Text survive until the renderer reads them"
    - "CLAY_TEXT elements get measured in character cells (1 char = 1 unit width)"
    - "Each CEL_Clay() call site in a layout function gets a unique Clay element ID"
    - "Project compiles with the new source file included"
  artifacts:
    - path: "include/cels-clay/clay_layout.h"
      provides: "All public types, macros, and function declarations for Phase 2 layout system"
      contains: "CEL_Clay"
    - path: "src/clay_layout.c"
      provides: "Frame arena, text measurement, auto-ID, layout pass state"
      contains: "g_frame_arena"
    - path: "CMakeLists.txt"
      provides: "Updated target_sources with clay_layout.c"
      contains: "clay_layout.c"
  key_links:
    - from: "include/cels-clay/clay_layout.h"
      to: "src/clay_layout.c"
      via: "header declares, source implements"
      pattern: "cel_clay_"
    - from: "CMakeLists.txt"
      to: "src/clay_layout.c"
      via: "target_sources INTERFACE"
      pattern: "clay_layout\\.c"
---

<objective>
Create the public header and foundational infrastructure for the Phase 2 layout system.

Purpose: Establish all types, macros, and support functions that the layout system (Plan 02) will use. This header IS the developer-facing API for cels-clay layout. The frame arena, text measurement, and auto-ID helper are critical infrastructure that must exist before the layout system can run.

Output: `clay_layout.h` (complete public API), partial `clay_layout.c` (infrastructure functions), updated `CMakeLists.txt`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-layout-system-core/02-CONTEXT.md
@.planning/phases/02-layout-system-core/02-RESEARCH.md
@.planning/API-DESIGN.md
@include/cels-clay/clay_engine.h
@src/clay_engine.c
@src/clay_impl.c
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: clay_layout.h -- Complete public header</name>
  <files>include/cels-clay/clay_layout.h</files>
  <action>
Create `include/cels-clay/clay_layout.h` with the full public API for the layout system.

**Architecture overview (for context -- do NOT include as comments in the header):**

C99 cannot define functions inside functions, so the developer workflow is:
1. Define layout functions at file scope with `CEL_Clay_Layout(name) { ... }`
2. Inside compositions, attach with `CEL_Has(ClayUI, .layout_fn = name)`
3. Inside layout functions, use `CEL_Clay(...)` which wraps `CLAY()` + auto-generated ID
4. Wrap the whole composition tree in `ClaySurface(.width = w, .height = h) { ... }`
5. The layout system calls stored layout functions between BeginLayout/EndLayout

This matches the API-DESIGN.md function-pointer model (which uses `ClayUI` as the component name) with auto-ID sugar from the context decisions.

**Include guards and includes:**
```c
#ifndef CELS_CLAY_LAYOUT_H
#define CELS_CLAY_LAYOUT_H

#include <cels/cels.h>
#include "clay.h"
#include <stdbool.h>
```

Note: This header DOES include clay.h (unlike clay_engine.h) because the macros need Clay types (Clay_ElementId, Clay_String, etc.).

**ClayUI component** (named `ClayUI` to match API-DESIGN.md and requirement API-02):
```c
typedef void (*CelClayLayoutFn)(ecs_world_t* world, ecs_entity_t self);

typedef struct ClayUI {
    CelClayLayoutFn layout_fn;
} ClayUI;

extern cels_entity_t ClayUIID;
extern cels_entity_t ClayUI_ensure(void);
```

IMPORTANT: The component is named `ClayUI` (not `ClayLayout`) for consistency with API-DESIGN.md reference code (`CEL_Has(ClayUI, .layout = root_layout)`) and requirement API-02.

**ClaySurfaceConfig component:**
```c
typedef struct ClaySurfaceConfig {
    float width;
    float height;
} ClaySurfaceConfig;

extern cels_entity_t ClaySurfaceConfigID;
extern cels_entity_t ClaySurfaceConfig_ensure(void);
```

**CEL_Clay_Layout(name) macro** -- defines a layout function signature:
```c
#define CEL_Clay_Layout(name) \
    static void name(ecs_world_t* world, ecs_entity_t self)
```

Add doc comment showing usage: define layout fn at file scope, reference it in `CEL_Has(ClayUI, .layout_fn = name)`.

**CEL_Clay(...) macro** -- wraps CLAY() with auto-generated ID:
```c
#define CEL_Clay(...) \
    CLAY(_cel_clay_auto_id(__COUNTER__), __VA_ARGS__)
```

Uses `__COUNTER__` (not `__LINE__`) for uniqueness. `__COUNTER__` increments per macro expansion within a translation unit, so two CEL_Clay calls on the same line (e.g., in a macro) still get unique IDs. Combined with the entity ID as seed, this produces globally unique IDs.

Add doc comment: use inside layout functions. Auto-generates unique Clay_ElementId from entity + call site. The trailing block contains CLAY_TEXT, nested CEL_Clay, CEL_Clay_Children, etc.

**CEL_Clay_Children() macro** -- emits child entities at this point in the tree:
```c
#define CEL_Clay_Children() \
    _cel_clay_emit_children()
```

Add doc comment: controls WHERE in the CLAY tree children appear. Example: header, then children, then footer.

**CEL_Clay_Text(buf, len) macro** -- creates Clay_String from dynamic buffer:
```c
#define CEL_Clay_Text(buf, len) \
    _cel_clay_frame_arena_string((buf), (len))
```

Add doc comment: copies buffer into per-frame arena so it survives until render. Use with CLAY_TEXT for dynamic (snprintf) strings.

**Internal function declarations** (needed by macros, prefixed with underscore):
```c
extern Clay_ElementId _cel_clay_auto_id(uint32_t counter);
extern void _cel_clay_emit_children(void);
extern Clay_String _cel_clay_frame_arena_string(const char* buf, int32_t len);
extern bool _cel_clay_layout_active(void);
```

**Layout subsystem lifecycle declarations** (called from clay_engine.c):
```c
extern void _cel_clay_layout_init(void);
extern void _cel_clay_layout_cleanup(void);
extern void _cel_clay_layout_system_register(void);
```

Close include guard: `#endif`

Do NOT include cell-aware sizing helpers (API-06 is N/A) or Clay_Get() helper (use CEL_Get/CEL_Watch).
  </action>
  <verify>
File exists at `include/cels-clay/clay_layout.h`. Contains all 4 macros (CEL_Clay, CEL_Clay_Layout, CEL_Clay_Children, CEL_Clay_Text), both component types (ClayUI, ClaySurfaceConfig), all extern function declarations. Component is named ClayUI (not ClayLayout). CEL_Clay uses __COUNTER__. Does NOT contain cell-aware sizing or Clay_Get.
  </verify>
  <done>
Header declares complete public API: ClayUI component with layout_fn pointer, ClaySurfaceConfig with width/height, CEL_Clay() auto-ID wrapper using __COUNTER__, CEL_Clay_Layout() function definer, CEL_Clay_Children() child emitter, CEL_Clay_Text() dynamic string helper, and all internal function declarations.
  </done>
</task>

<task type="auto">
  <name>Task 2: clay_layout.c infrastructure + CMakeLists.txt update</name>
  <files>src/clay_layout.c, CMakeLists.txt</files>
  <action>
Create `src/clay_layout.c` with foundational infrastructure. This file will be extended in Plan 02 with the layout system and tree walk.

**Includes:**
```c
#include "cels-clay/clay_layout.h"
#include "clay.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
```

**Component registration** -- use `cels_component_register()` (NOT direct flecs API). Component is named `ClayUI` to match API-DESIGN.md:
```c
cels_entity_t ClayUIID = 0;
cels_entity_t ClaySurfaceConfigID = 0;

cels_entity_t ClayUI_ensure(void) {
    if (ClayUIID == 0) {
        ClayUIID = cels_component_register("ClayUI",
            sizeof(ClayUI), CELS_ALIGNOF(ClayUI));
    }
    return ClayUIID;
}

cels_entity_t ClaySurfaceConfig_ensure(void) {
    if (ClaySurfaceConfigID == 0) {
        ClaySurfaceConfigID = cels_component_register("ClaySurfaceConfig",
            sizeof(ClaySurfaceConfig), CELS_ALIGNOF(ClaySurfaceConfig));
    }
    return ClaySurfaceConfigID;
}
```

This matches the pattern in cels.h `CEL_Define` (line 312-320) but with `extern` linkage for cross-file use in the module. Uses `CELS_ALIGNOF` (defined in cels.h, handles C99/C11/GCC differences).

**Frame arena** (per-frame bump allocator for dynamic strings):
```c
typedef struct {
    char* memory;
    size_t capacity;
    size_t offset;
} _CelClayFrameArena;

static _CelClayFrameArena g_frame_arena = {0};
#define CEL_CLAY_FRAME_ARENA_SIZE (16 * 1024)  /* 16KB */
```

Implement `_cel_clay_frame_arena_string()` -- copies buf into arena, returns Clay_String with `isStaticallyAllocated = false`. On overflow: stderr warning, return empty string (do not crash). On len <= 0: return empty string.

Implement static `_cel_clay_frame_arena_reset()` -- sets offset to 0 (called before BeginLayout each frame).

**Text measurement** -- terminal cell-based (1 char = 1 unit):
```c
static Clay_Dimensions _cel_clay_measure_text(
    Clay_StringSlice text,
    Clay_TextElementConfig* config,
    void* userData)
```

Counts characters as width, newlines increment height. Matches Clay's terminal renderer example pattern. IMPORTANT: verify the callback signature uses `Clay_StringSlice` (not `Clay_String`) in Clay v0.14 by checking clay.h.

**Layout pass state** (globals used by tree walk in Plan 02):
```c
static ecs_world_t* g_layout_world = NULL;
static ecs_entity_t g_layout_current_entity = 0;
static bool g_layout_pass_active = false;
```

**Auto-ID generation** -- uses `__COUNTER__` value (passed from macro):
```c
Clay_ElementId _cel_clay_auto_id(uint32_t counter) {
    uint32_t seed = (uint32_t)g_layout_current_entity;
    return Clay__HashNumber(counter, seed);
}

bool _cel_clay_layout_active(void) {
    return g_layout_pass_active;
}
```

Entity ID as seed + `__COUNTER__` as offset. Entity IDs are unique in flecs, `__COUNTER__` is unique per macro expansion site within a TU.

**Init and cleanup:**

`_cel_clay_layout_init()`: malloc frame arena, call `Clay_SetMeasureTextFunction`, call both component ensure functions.

`_cel_clay_layout_cleanup()`: free frame arena memory, zero out struct.

**Stubs for Plan 02:**
```c
void _cel_clay_emit_children(void) {
    /* Stub: implemented in Plan 02 */
}

void _cel_clay_layout_system_register(void) {
    /* Stub: implemented in Plan 02 */
}
```

**CMakeLists.txt** -- add `clay_layout.c` to target_sources:
```cmake
target_sources(cels-clay INTERFACE
    ${CMAKE_CURRENT_SOURCE_DIR}/src/clay_impl.c
    ${CMAKE_CURRENT_SOURCE_DIR}/src/clay_engine.c
    ${CMAKE_CURRENT_SOURCE_DIR}/src/clay_layout.c
)
```

**Build verification:** After creating both files, run the project build to confirm no compile errors, no duplicate symbols, no undefined references.
  </action>
  <verify>
1. `src/clay_layout.c` exists with all implementations described above
2. Component variables are `ClayUIID` and `ClaySurfaceConfigID` (not ClayLayoutID)
3. `CMakeLists.txt` has clay_layout.c in target_sources
4. Build succeeds: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | tail -20`
5. No duplicate symbol or undefined reference errors
  </verify>
  <done>
clay_layout.c implements: 16KB frame arena with bump alloc/reset/cleanup, terminal text measurement function, auto-ID via Clay__HashNumber(__COUNTER__, entity_id), component registration for ClayUI and ClaySurfaceConfig using cels_component_register, init/cleanup lifecycle, layout pass state globals. Stubs for tree walk and system registration. CMakeLists.txt updated. Project compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `include/cels-clay/clay_layout.h` exists with all macros and declarations
2. `src/clay_layout.c` exists with infrastructure implementations
3. Component is named ClayUI (matching API-DESIGN.md), not ClayLayout
4. CEL_Clay uses __COUNTER__ for auto-ID uniqueness
5. `CMakeLists.txt` includes clay_layout.c
6. Project builds without errors
7. No duplicate symbols, no undefined references
</verification>

<success_criteria>
- clay_layout.h is the complete public API header for the layout system
- Component named ClayUI with layout_fn pointer (matches API-02 and API-DESIGN.md)
- Frame arena: 16KB default, bump allocation, reset function, overflow protection
- Text measurement: character-cell counting with newline support
- Auto-ID: Clay__HashNumber(__COUNTER__, entity_id) produces unique IDs
- Layout pass state globals ready for Plan 02
- CMake updated, project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-layout-system-core/02-01-SUMMARY.md`
</output>
