---
phase: 02-layout-system-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/cels-clay/clay_layout.h
  - src/clay_layout.c
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "clay_layout.h declares all public types and macros for the layout system"
    - "Frame arena allocates and resets memory for per-frame dynamic strings"
    - "Text measurement function counts characters as 1-unit cells with newline support"
    - "Auto-ID helper generates unique Clay_ElementId from entity ID + counter"
    - "Project compiles with the new source file included"
  artifacts:
    - path: "include/cels-clay/clay_layout.h"
      provides: "All public types, macros, and function declarations for Phase 2 layout system"
      contains: "CEL_Clay"
    - path: "src/clay_layout.c"
      provides: "Frame arena, text measurement, auto-ID, layout pass state"
      contains: "g_frame_arena"
    - path: "CMakeLists.txt"
      provides: "Updated target_sources with clay_layout.c"
      contains: "clay_layout.c"
  key_links:
    - from: "include/cels-clay/clay_layout.h"
      to: "src/clay_layout.c"
      via: "header declares, source implements"
      pattern: "cel_clay_"
    - from: "CMakeLists.txt"
      to: "src/clay_layout.c"
      via: "target_sources INTERFACE"
      pattern: "clay_layout\\.c"
---

<objective>
Create the public header and foundational infrastructure for the Phase 2 layout system.

Purpose: Establish all types, macros, and support functions that the layout system (Plan 02) will use. This header IS the developer-facing API for cels-clay layout. The frame arena, text measurement, and auto-ID helper are critical infrastructure that must exist before the layout system can run.

Output: `clay_layout.h` (complete public API), partial `clay_layout.c` (infrastructure functions), updated `CMakeLists.txt`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-layout-system-core/02-CONTEXT.md
@.planning/phases/02-layout-system-core/02-RESEARCH.md
@include/cels-clay/clay_engine.h
@src/clay_engine.c
@src/clay_impl.c
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: clay_layout.h -- Complete public header</name>
  <files>include/cels-clay/clay_layout.h</files>
  <action>
Create `include/cels-clay/clay_layout.h` with the full public API for the layout system.

**Architecture overview (for context -- do NOT include as comments in the header):**

C99 cannot define functions inside functions, so the developer workflow is:
1. Define layout functions at file scope with `CEL_Clay_Layout(name) { ... }`
2. Inside compositions, attach with `CEL_Has(ClayLayout, .layout_fn = name)`
3. Inside layout functions, use `CEL_Clay(...)` which wraps `CLAY()` + auto-generated ID
4. Wrap the whole composition tree in `ClaySurface(.width = w, .height = h) { ... }`
5. The layout system calls stored layout functions between BeginLayout/EndLayout

This matches the API-DESIGN.md function-pointer model with auto-ID sugar from the context decisions.

**Include guards and includes:**
```c
#ifndef CELS_CLAY_LAYOUT_H
#define CELS_CLAY_LAYOUT_H

#include <cels/cels.h>
#include "clay.h"
#include <stdbool.h>
```

Note: This header DOES include clay.h (unlike clay_engine.h) because the macros need Clay types (Clay_ElementId, Clay_String, etc.).

**ClayLayout component:**
```c
typedef void (*CelClayLayoutFn)(ecs_world_t* world, ecs_entity_t self);

typedef struct ClayLayout {
    CelClayLayoutFn layout_fn;
} ClayLayout;

extern cels_entity_t ClayLayoutID;
extern cels_entity_t ClayLayout_ensure(void);
```

**ClaySurfaceConfig component:**
```c
typedef struct ClaySurfaceConfig {
    float width;
    float height;
} ClaySurfaceConfig;

extern cels_entity_t ClaySurfaceConfigID;
extern cels_entity_t ClaySurfaceConfig_ensure(void);
```

**CEL_Clay_Layout(name) macro** -- defines a layout function signature:
```c
#define CEL_Clay_Layout(name) \
    static void name(ecs_world_t* world, ecs_entity_t self)
```

Add doc comment showing usage: define layout fn at file scope, reference it in CEL_Has(ClayLayout, .layout_fn = name).

**CEL_Clay(...) macro** -- wraps CLAY() with auto-generated ID:
```c
#define CEL_Clay(...) \
    CLAY(_cel_clay_auto_id(__LINE__), __VA_ARGS__)
```

Add doc comment: use inside layout functions. Auto-generates unique Clay_ElementId from entity + call site. The trailing block contains CLAY_TEXT, nested CEL_Clay, CEL_Clay_Children, etc.

**CEL_Clay_Children() macro** -- emits child entities at this point in the tree:
```c
#define CEL_Clay_Children() \
    _cel_clay_emit_children()
```

Add doc comment: controls WHERE in the CLAY tree children appear. Example: header, then children, then footer.

**CEL_Clay_Text(buf, len) macro** -- creates Clay_String from dynamic buffer:
```c
#define CEL_Clay_Text(buf, len) \
    _cel_clay_frame_arena_string((buf), (len))
```

Add doc comment: copies buffer into per-frame arena so it survives until render. Use with CLAY_TEXT for dynamic (snprintf) strings.

**Internal function declarations** (needed by macros, prefixed with underscore):
```c
extern Clay_ElementId _cel_clay_auto_id(uint32_t line);
extern void _cel_clay_emit_children(void);
extern Clay_String _cel_clay_frame_arena_string(const char* buf, int32_t len);
extern bool _cel_clay_layout_active(void);
```

**Layout subsystem lifecycle declarations** (called from clay_engine.c):
```c
extern void _cel_clay_layout_init(void);
extern void _cel_clay_layout_cleanup(void);
extern void _cel_clay_layout_system_register(void);
```

Close include guard: `#endif`

Do NOT include cell-aware sizing helpers (API-06 is N/A) or Clay_Get() helper (use CEL_Get/CEL_Watch).
  </action>
  <verify>
File exists at `include/cels-clay/clay_layout.h`. Contains all 4 macros (CEL_Clay, CEL_Clay_Layout, CEL_Clay_Children, CEL_Clay_Text), both component types (ClayLayout, ClaySurfaceConfig), all extern function declarations. Does NOT contain cell-aware sizing or Clay_Get.
  </verify>
  <done>
Header declares complete public API: ClayLayout component with layout_fn pointer, ClaySurfaceConfig with width/height, CEL_Clay() auto-ID wrapper, CEL_Clay_Layout() function definer, CEL_Clay_Children() child emitter, CEL_Clay_Text() dynamic string helper, and all internal function declarations.
  </done>
</task>

<task type="auto">
  <name>Task 2: clay_layout.c infrastructure + CMakeLists.txt update</name>
  <files>src/clay_layout.c, CMakeLists.txt</files>
  <action>
Create `src/clay_layout.c` with foundational infrastructure. This file will be extended in Plan 02 with the layout system and tree walk.

**Includes:**
```c
#include "cels-clay/clay_layout.h"
#include "clay.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
```

**Component registration** -- use `cels_component_register()` (NOT direct flecs API):
```c
cels_entity_t ClayLayoutID = 0;
cels_entity_t ClaySurfaceConfigID = 0;

cels_entity_t ClayLayout_ensure(void) {
    if (ClayLayoutID == 0) {
        ClayLayoutID = cels_component_register("ClayLayout",
            sizeof(ClayLayout), CELS_ALIGNOF(ClayLayout));
    }
    return ClayLayoutID;
}

cels_entity_t ClaySurfaceConfig_ensure(void) {
    if (ClaySurfaceConfigID == 0) {
        ClaySurfaceConfigID = cels_component_register("ClaySurfaceConfig",
            sizeof(ClaySurfaceConfig), CELS_ALIGNOF(ClaySurfaceConfig));
    }
    return ClaySurfaceConfigID;
}
```

This matches the pattern in cels.h `CEL_Define` (line 312-320) but with `extern` linkage for cross-file use in the module.

**Frame arena** (per-frame bump allocator for dynamic strings):
```c
typedef struct {
    char* memory;
    size_t capacity;
    size_t offset;
} _CelClayFrameArena;

static _CelClayFrameArena g_frame_arena = {0};
#define CEL_CLAY_FRAME_ARENA_SIZE (16 * 1024)  /* 16KB */
```

Implement `_cel_clay_frame_arena_string()` -- copies buf into arena, returns Clay_String with `isStaticallyAllocated = false`. On overflow: stderr warning, return empty string (do not crash). On len <= 0: return empty string.

Implement static `_cel_clay_frame_arena_reset()` -- sets offset to 0 (called before BeginLayout each frame).

**Text measurement** -- terminal cell-based (1 char = 1 unit):
```c
static Clay_Dimensions _cel_clay_measure_text(
    Clay_StringSlice text,
    Clay_TextElementConfig* config,
    void* userData)
```

Counts characters as width, newlines increment height. Matches Clay's terminal renderer example pattern. IMPORTANT: verify the callback signature uses `Clay_StringSlice` (not `Clay_String`) in Clay v0.14 by checking clay.h.

**Layout pass state** (globals used by tree walk in Plan 02):
```c
static ecs_world_t* g_layout_world = NULL;
static ecs_entity_t g_layout_current_entity = 0;
static bool g_layout_pass_active = false;
```

**Auto-ID generation:**
```c
Clay_ElementId _cel_clay_auto_id(uint32_t line) {
    uint32_t seed = (uint32_t)g_layout_current_entity;
    return Clay__HashNumber(line, seed);
}

bool _cel_clay_layout_active(void) {
    return g_layout_pass_active;
}
```

Uses entity ID as seed + `__LINE__` as offset. Entity IDs are unique in flecs, `__LINE__` is unique per call site.

**Init and cleanup:**

`_cel_clay_layout_init()`: malloc frame arena, call `Clay_SetMeasureTextFunction`, call both component ensure functions.

`_cel_clay_layout_cleanup()`: free frame arena memory, zero out struct.

**Stubs for Plan 02:**
```c
void _cel_clay_emit_children(void) {
    /* Stub: implemented in Plan 02 */
}

void _cel_clay_layout_system_register(void) {
    /* Stub: implemented in Plan 02 */
}
```

**CMakeLists.txt** -- add `clay_layout.c` to target_sources:
```cmake
target_sources(cels-clay INTERFACE
    ${CMAKE_CURRENT_SOURCE_DIR}/src/clay_impl.c
    ${CMAKE_CURRENT_SOURCE_DIR}/src/clay_engine.c
    ${CMAKE_CURRENT_SOURCE_DIR}/src/clay_layout.c
)
```

**Build verification:** After creating both files, run the project build to confirm no compile errors, no duplicate symbols, no undefined references.
  </action>
  <verify>
1. `src/clay_layout.c` exists with all implementations described above
2. `CMakeLists.txt` has clay_layout.c in target_sources
3. Build succeeds: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | tail -20`
4. No duplicate symbol or undefined reference errors
  </verify>
  <done>
clay_layout.c implements: 16KB frame arena with bump alloc/reset/cleanup, terminal text measurement function, auto-ID via Clay__HashNumber, component registration using cels_component_register, init/cleanup lifecycle, layout pass state globals. Stubs for tree walk and system registration. CMakeLists.txt updated. Project compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `include/cels-clay/clay_layout.h` exists with all macros and declarations
2. `src/clay_layout.c` exists with infrastructure implementations
3. `CMakeLists.txt` includes clay_layout.c
4. Project builds without errors
5. No duplicate symbols, no undefined references
</verification>

<success_criteria>
- clay_layout.h is the complete public API header for the layout system
- Frame arena: 16KB default, bump allocation, reset function, overflow protection
- Text measurement: character-cell counting with newline support
- Auto-ID: Clay__HashNumber(line, entity_id) produces unique IDs
- Components: ClayLayout and ClaySurfaceConfig registered via cels_component_register
- Layout pass state globals ready for Plan 02
- CMake updated, project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-layout-system-core/02-01-SUMMARY.md`
</output>
