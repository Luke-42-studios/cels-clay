---
phase: 02-layout-system-core
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - include/cels-clay/clay_layout.h
  - src/clay_layout.c
autonomous: true

must_haves:
  truths:
    - "ClaySurface is a usable composition that wraps its children in a Clay layout pass"
    - "CEL_Clay() inside a layout function produces correct CLAY() calls with unique IDs"
    - "CEL_Clay_Children() correctly emits children inside a parent CLAY scope"
    - "CEL_Clay_Text() copies dynamic strings into the frame arena"
    - "All 5 phase success criteria are verifiable at the code level"
  artifacts:
    - path: "include/cels-clay/clay_layout.h"
      provides: "ClaySurface composition declaration and shorthand macro"
      contains: "ClaySurface"
    - path: "src/clay_layout.c"
      provides: "No new code unless build fixes needed"
      contains: "clay_walk_entity"
  key_links:
    - from: "ClaySurface composition"
      to: "ClaySurfaceConfig component"
      via: "CEL_Has(ClaySurfaceConfig) in composition body"
      pattern: "CEL_Has.*ClaySurfaceConfig"
---

<objective>
Add the ClaySurface built-in composition to the header and validate the complete layout pipeline compiles and connects correctly.

Purpose: ClaySurface is the developer entry point -- wrapping compositions in ClaySurface(.width, .height) makes them participate in Clay layout. Without ClaySurface, the layout system has no root to walk. This plan also validates that all pieces from Plans 01-02 connect into a working pipeline.

Output: ClaySurface composition in `clay_layout.h`, fully compiled and verified layout system.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-layout-system-core/02-CONTEXT.md
@.planning/phases/02-layout-system-core/02-RESEARCH.md
@.planning/phases/02-layout-system-core/02-01-PLAN.md
@.planning/phases/02-layout-system-core/02-02-PLAN.md
@.planning/API-DESIGN.md
@include/cels-clay/clay_layout.h
@include/cels-clay/clay_engine.h
@src/clay_layout.c
@src/clay_engine.c
</context>

<tasks>

<task type="auto">
  <name>Task 1: ClaySurface composition in clay_layout.h</name>
  <files>include/cels-clay/clay_layout.h</files>
  <action>
Add ClaySurface as a built-in CELS composition to `clay_layout.h`.

ClaySurface is the entry point for Clay layout. It attaches `ClaySurfaceConfig` to the entity so the `ClayLayoutSystem` (from Plan 02) finds it and runs the layout pass. Usage:

```c
CEL_Root(App) {
    Clay_Engine_use((Clay_EngineConfig){0});
    ClaySurface(.width = 80, .height = 24) {
        Sidebar() {}
        Content() {}
    }
}
```

**Add to clay_layout.h** (AFTER the ClaySurfaceConfig component declaration, BEFORE `#endif`):

1. The composition definition using `CEL_Composition`:
```c
CEL_Composition(ClaySurface, float width; float height;) {
    CEL_Has(ClaySurfaceConfig, .width = props.width, .height = props.height);
}
```

2. The shorthand invocation macro (MUST come AFTER the CEL_Composition definition to avoid the preprocessor expanding the token `ClaySurface` inside the composition body):
```c
#define ClaySurface(...) CEL_Init(ClaySurface, __VA_ARGS__)
```

This works because `CEL_Composition` generates static functions (safe in headers -- each TU gets its own copy). The shorthand macro follows the standard CELS pattern (see API-DESIGN.md `#define Button(...) CEL_Init(Button, __VA_ARGS__)`).

Add a doc comment above the composition explaining:
- ClaySurface owns the Clay layout pass boundary
- Accepts reactive dimensions (width, height)
- All Clay-enabled children inside ClaySurface participate in the layout tree
- App should wire window size to these props for resize support

**Do NOT** add an if/else safety guard to the CEL_Clay macro. Layout functions are only called by the tree walk (which runs between Begin/End), so the check is unnecessary. Clay's own error handler catches any misuse (unbalanced open/close). This is documented in the CEL_Clay header doc comment (from Plan 01).
  </action>
  <verify>
1. `clay_layout.h` contains `CEL_Composition(ClaySurface, float width; float height;)`
2. `clay_layout.h` contains `#define ClaySurface(...) CEL_Init(ClaySurface, __VA_ARGS__)`
3. The shorthand macro appears AFTER the CEL_Composition definition
4. ClaySurface composition body calls `CEL_Has(ClaySurfaceConfig, .width = props.width, .height = props.height)`
5. Build succeeds with no errors or macro conflicts
  </verify>
  <done>
ClaySurface is a usable built-in composition in the header. Shorthand macro enables `ClaySurface(.width = w, .height = h) { children }` syntax. Composition attaches ClaySurfaceConfig component so the layout system finds it. No if/else guard on CEL_Clay (Clay handles misuse).
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end compile validation + phase success criteria check</name>
  <files>src/clay_layout.c</files>
  <action>
Validate the complete layout pipeline by performing a full build and verifying all connections.

**Step 1: Full build**

```bash
cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1
```

Fix any compilation errors. Common issues to watch for:
- Missing includes (ecs_world_t needs flecs.h, which should come via cels.h)
- Wrong flecs API (ecs_each_id may not exist in this flecs version -- check alternatives)
- `EcsPreStore` phase constant may have a different name -- check flecs headers
- Clay v0.14 API differences (Clay_StringSlice vs Clay_String in text measurement callback)
- CEL_Composition in header causing multiple definition errors (should be fine with static functions)

**Step 2: Verify existing tests still pass**

```bash
cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_test && ./build/tests/cels_test
```

No regressions allowed.

**Step 3: Verify all 5 phase success criteria at code level**

1. "CEL_Clay() scope inside a composition opens an entity-backed CLAY() block" -- Verify CEL_Clay macro wraps CLAY() with auto-ID. All Clay macros work inside because it IS a CLAY() scope.

2. "Parent-child entity relationships produce correctly nested CLAY() output in deterministic depth-first order" -- Verify clay_walk_entity is recursive, uses ecs_children.

3. "Layout system runs at PreStore phase each frame" -- Verify ClayLayoutSystem_Run brackets tree walk with BeginLayout/EndLayout, registered at PreStore.

4. "Terminal resize updates propagate to Clay_SetLayoutDimensions" -- Verify system reads ClaySurfaceConfig each frame and calls SetLayoutDimensions.

5. "Text measurement callback is registered" -- Verify _cel_clay_layout_init calls Clay_SetMeasureTextFunction.

**Step 4: Fix any issues found**

If the build revealed issues, fix them in the relevant source file. Do NOT add new features. Only fix compilation and connection issues.
  </action>
  <verify>
1. `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | grep -i error` returns nothing
2. All existing tests pass (if test target exists)
3. grep confirms: CEL_Clay wraps CLAY(), tree walk is recursive, system at PreStore, SetLayoutDimensions called, SetMeasureTextFunction called
4. No compiler warnings related to cels-clay files
  </verify>
  <done>
Full project compiles with zero errors. All 5 phase success criteria verified at code level. Existing tests pass. No regressions. Layout pipeline fully wired end-to-end.
  </done>
</task>

</tasks>

<verification>
1. ClaySurface composition exists in header and is invocable with shorthand macro
2. Full project builds with zero errors
3. All 5 phase success criteria verified at code level:
   - CEL_Clay -> CLAY() with auto-ID (success criterion 1)
   - Recursive depth-first tree walk (success criterion 2)
   - PreStore system with BeginLayout/EndLayout (success criterion 3)
   - ClaySurface dimensions -> Clay_SetLayoutDimensions (success criterion 4)
   - Text measurement callback registered (success criterion 5)
4. Existing tests pass
5. No compiler warnings from cels-clay source files
</verification>

<success_criteria>
- ClaySurface is a working built-in composition with shorthand macro
- Full build succeeds with zero errors
- All 5 phase success criteria from ROADMAP.md verified
- No regressions to existing tests
- Layout pipeline fully wired: Clay_Engine_use -> layout init -> system registration -> per-frame layout pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-layout-system-core/02-03-SUMMARY.md`
</output>
