---
phase: 02-layout-system-core
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - include/cels-clay/clay_layout.h
  - src/clay_layout.c
autonomous: true

must_haves:
  truths:
    - "ClaySurface is a usable composition that wraps its children in a Clay layout pass"
    - "CEL_Clay() inside a layout function produces correct CLAY() calls with unique IDs"
    - "CEL_Clay_Children() correctly emits children inside a parent CLAY scope"
    - "CEL_Clay_Text() copies dynamic strings into the frame arena"
    - "CEL_Clay() outside a layout pass prints stderr warning and is safely ignored"
    - "All 5 phase success criteria are verifiable at the code level"
  artifacts:
    - path: "include/cels-clay/clay_layout.h"
      provides: "ClaySurface composition declaration added to header"
      contains: "ClaySurface"
    - path: "src/clay_layout.c"
      provides: "ClaySurface composition implementation, layout pass safety check in CEL_Clay"
      contains: "CEL_Composition(ClaySurface"
  key_links:
    - from: "ClaySurface composition"
      to: "ClaySurfaceConfig component"
      via: "CEL_Has(ClaySurfaceConfig) in composition body"
      pattern: "CEL_Has.*ClaySurfaceConfig"
    - from: "CEL_Clay macro"
      to: "_cel_clay_layout_active"
      via: "safety check before CLAY() call"
      pattern: "_cel_clay_layout_active"
---

<objective>
Add the ClaySurface built-in composition, layout pass safety checks, and validate the complete layout pipeline compiles and connects correctly.

Purpose: ClaySurface is the developer entry point -- wrapping compositions in ClaySurface(.width, .height) makes them participate in Clay layout. Without ClaySurface, the layout system has no root to walk. This plan also adds the safety check that CEL_Clay() warns if called outside a layout pass, and validates that all pieces from Plans 01-02 connect into a working pipeline.

Output: ClaySurface composition in clay_layout.c, safety-checked CEL_Clay macro, complete working layout system.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-layout-system-core/02-CONTEXT.md
@.planning/phases/02-layout-system-core/02-RESEARCH.md
@.planning/phases/02-layout-system-core/02-01-PLAN.md
@.planning/phases/02-layout-system-core/02-02-PLAN.md
@include/cels-clay/clay_layout.h
@include/cels-clay/clay_engine.h
@src/clay_layout.c
@src/clay_engine.c
</context>

<tasks>

<task type="auto">
  <name>Task 1: ClaySurface composition + layout pass safety check</name>
  <files>src/clay_layout.c, include/cels-clay/clay_layout.h</files>
  <action>
**ClaySurface composition** in clay_layout.c:

ClaySurface is a built-in CELS composition provided by the module. It attaches ClaySurfaceConfig to the entity so the ClayLayoutSystem finds it and runs the layout pass. The developer wraps their composition tree in ClaySurface:

```c
CEL_Root(App) {
    Clay_Engine_use((Clay_EngineConfig){0});
    ClaySurface(.width = 80, .height = 24) {
        Sidebar() {}
        Content() {}
    }
}
```

ClaySurface needs to be defined as a CELS composition. However, since cels-clay is an INTERFACE library (sources compile in the consumer's context), we can use standard CEL_Composition:

```c
CEL_Composition(ClaySurface, float width; float height;) {
    CEL_Has(ClaySurfaceConfig, .width = props.width, .height = props.height);
}
```

Wait -- CEL_Composition in cels.h uses `_CEL_Compose` which is a for-loop that calls `cels_begin_entity`/`cels_end_entity`. This creates a child entity scope. The composition body runs between begin/end. Children declared in the trailing block become child entities of the ClaySurface entity. This is exactly what we want -- the layout system walks ClaySurface's children.

HOWEVER: CEL_Composition generates static functions and variables. Since this is in an INTERFACE library .c file that compiles in the consumer's TU, we need to be careful about symbol visibility. The composition function should be `static` (which CEL_Composition already generates).

There is a potential issue: `CEL_Composition` generates a `static` composition function. But for the consumer to USE `ClaySurface(...)`, the composition must be visible. Check how CEL_Composition works:

Looking at cels.h: `CEL_Composition(Name, ...)` generates a static composition body function AND a macro `#define Name(...) CEL_Init(Name, __VA_ARGS__)` for invocation. But since CEL_Composition uses `#define`, this only works if the definition is in a header file that the consumer includes.

REVISED APPROACH: The ClaySurface composition definition belongs in `clay_layout.h` (the header), not in `clay_layout.c`. This way consumers who include the header get the composition macro.

Actually, looking more carefully at CEL_Composition expansion: it defines a static function. If in a header, every TU that includes it gets a copy (which is fine for static). The key parts:
1. The composition body function (static) -- can be in header
2. The invocation macro -- must be in header

So define ClaySurface in `clay_layout.h`:

```c
/* ClaySurface -- Built-in composition that owns the Clay layout pass.
 *
 * Wrap your composition tree in ClaySurface to enable Clay layout:
 *
 *   CEL_Root(App) {
 *       Clay_Engine_use((Clay_EngineConfig){0});
 *       ClaySurface(.width = 80, .height = 24) {
 *           MyLayout() {}
 *       }
 *   }
 *
 * ClaySurface accepts reactive dimensions. Update width/height when the
 * window resizes and the layout adapts automatically.
 */
CEL_Composition(ClaySurface, float width; float height;) {
    CEL_Has(ClaySurfaceConfig, .width = props.width, .height = props.height);
}
```

WAIT: CEL_Composition generates `static` functions inside the header. This is standard for header-defined compositions in CELS (inline pattern). But we need to verify there is no issue with the `_CEL_CAT` and static latch variables. Read CEL_Composition expansion carefully.

Actually, there is a simpler alternative: define the composition as a macro in the header that directly creates the entity with the right component:

```c
#define ClaySurface(...) \
    _CEL_CLAY_SURFACE_EXPAND(__VA_ARGS__)
```

No -- let's just use CEL_Composition. It's designed to work in headers (static functions). Add it to `clay_layout.h` BEFORE the `#endif` guard.

**Layout pass safety check for CEL_Clay:**

Update the CEL_Clay macro in clay_layout.h to check if the layout pass is active. If not, print a warning and skip the CLAY() call.

The challenge: CEL_Clay currently expands to `CLAY(...)` which is a for-loop. We can't conditionally skip a for-loop in a macro without wrapping it.

Revised CEL_Clay macro:
```c
#define CEL_Clay(...) \
    if (!_cel_clay_layout_active()) { \
        fprintf(stderr, "[cels-clay] CEL_Clay() used outside layout pass " \
                "(missing ClaySurface ancestor?)\n"); \
    } else \
    CLAY(_cel_clay_auto_id(__LINE__), __VA_ARGS__)
```

This uses the `if/else` trick: if layout is inactive, the warning prints and the `else` branch (CLAY for-loop + trailing block) is skipped. The trailing `{...}` block the user writes attaches to the CLAY for-loop in the else branch.

HOWEVER: The dangling-else problem. If the user writes:
```c
CEL_Clay(.layout = {...}) {
    CLAY_TEXT(...);
}
```

This becomes:
```c
if (!active) { warn; } else CLAY(id, .layout = {...}) {
    CLAY_TEXT(...);
}
```

This is syntactically valid. The CLAY for-loop's body IS the user's block. And the if/else correctly gates it.

But there's a subtle issue: if CEL_Clay is used inside another if/else, the dangling else could bind incorrectly. To avoid this, wrap in a do-while or use a different pattern.

Better approach -- use a simple runtime check inside the layout function, not in the macro:

Actually, the simplest safe approach: since CEL_Clay is ONLY used inside layout functions (which are ONLY called by the tree walk system during the layout pass), the check is mostly a developer-safety net. The warning is helpful during development but not critical for correctness.

Keep it simple: add the check as a separate function the developer CAN call, but don't embed it in the macro. The macro stays clean:

```c
#define CEL_Clay(...) \
    CLAY(_cel_clay_auto_id(__LINE__), __VA_ARGS__)
```

Instead, add a CHECK at the start of the layout system's tree walk -- before calling any layout functions, verify the pass is active. And document that CEL_Clay must only be used inside layout functions.

For the "used outside ClaySurface subtree" warning from the context decision: this is already handled because layout functions are ONLY called during the tree walk, which ONLY happens between Begin/End. If someone calls a layout function manually outside the pass, the CLAY() calls would happen outside Begin/End and Clay itself would detect the error (unbalanced open/close).

FINAL DECISION: Keep CEL_Clay as a clean CLAY() wrapper. Do NOT add if/else guard (dangling-else risk). Add a note in the header doc comment that CEL_Clay must only be used inside CEL_Clay_Layout functions. Clay's own error handler catches misuse.

**Update clay_layout.h with:**
1. ClaySurface composition definition (using CEL_Composition macro)
2. Ensure ClaySurface composition comes AFTER the ClaySurfaceConfig component declaration
3. Add `#include <stdio.h>` if not already included (for fprintf in the composition? No -- CEL_Composition doesn't need stdio)

**Verify the ClaySurface shorthand macro** -- CEL_Composition generates:
```c
#define ClaySurface(...) CEL_Init(ClaySurface, __VA_ARGS__)
```

Wait -- CEL_Composition does NOT generate the shorthand macro automatically. Looking at the API-DESIGN.md counter example:
```c
#define Button(...) CEL_Init(Button, __VA_ARGS__)
CEL_Composition(Button, ...) { ... }
```

The `#define Button(...)` is manually added. CEL_Composition itself does not produce this.

BUT looking at cels.h more carefully at the CEL_Composition expansion (lines 554+), the composition IS invoked via `CEL_Init(ClaySurface, .width = 80, .height = 24)`. So either:
- Add `#define ClaySurface(...) CEL_Init(ClaySurface, __VA_ARGS__)` in the header, OR
- Let the user call `CEL_Init(ClaySurface, .width = 80, .height = 24) { children }`

The shorthand macro is cleaner. Add it after the composition definition.

IMPORTANT: The shorthand `#define ClaySurface(...)` conflicts with the `CEL_Composition(ClaySurface, ...)` if they're in the same file, because the macro would expand `ClaySurface` inside `CEL_Composition(ClaySurface, ...)`. To avoid this:
1. Define the composition FIRST
2. Define the shorthand macro AFTER
3. OR use `#undef ClaySurface` before defining the shorthand... no, that breaks things.

Actually, looking at the CELS example pattern more carefully: `CEL_Composition(Button, ...)` uses the token `Button` as part of `_CEL_ComposeBody_Button` etc. The `#define Button(...)` AFTER the composition definition is fine because at that point the composition is already defined. The shorthand just makes invocation easier.

The standard CELS pattern from cels.h is:
```c
CEL_Composition(Name, props...) { body }  // defines composition
// Then separately:
#define Name(...) CEL_Init(Name, __VA_ARGS__)  // shorthand
```

BUT in a header file, if `#define ClaySurface(...)` appears BEFORE any other use of the token `ClaySurface`, it would cause issues. Place the shorthand as the LAST thing related to ClaySurface.

Actually, there is a real problem: `CEL_Composition(ClaySurface, ...)` internally generates identifiers like `_CEL_ComposeBody_ClaySurface`. If `#define ClaySurface(...)` is active, the token `ClaySurface` in `CEL_Composition(ClaySurface, ...)` would be macro-expanded. So the macro definition MUST come AFTER the CEL_Composition definition.

Order in header:
1. CEL_Composition(ClaySurface, ...) { ... }  -- defines the composition
2. `#define ClaySurface(...) CEL_Init(ClaySurface, __VA_ARGS__)` -- shorthand

This works because the preprocessor processes top-to-bottom. The CEL_Composition definition is processed first (the token ClaySurface is not yet a macro), then the #define makes it a macro for future uses.

**Summary of changes to clay_layout.h:**
1. Add ClaySurface composition definition (CEL_Composition macro)
2. Add ClaySurface shorthand invocation macro
3. Keep CEL_Clay macro clean (no if/else guard)

**Summary of changes to clay_layout.c:**
1. No changes needed from this task (unless build issues arise)

**Build and verify:** Compile the project. Verify ClaySurface composition definition compiles correctly.
  </action>
  <verify>
1. `clay_layout.h` contains `CEL_Composition(ClaySurface, ...)`
2. `clay_layout.h` contains `#define ClaySurface(...) CEL_Init(ClaySurface, __VA_ARGS__)`
3. ClaySurface composition body calls `CEL_Has(ClaySurfaceConfig, .width = props.width, .height = props.height)`
4. Build succeeds with no errors
5. No macro expansion conflicts between CEL_Composition(ClaySurface) and #define ClaySurface
  </verify>
  <done>
ClaySurface is a usable built-in composition: wraps children in a Clay layout surface with configurable dimensions. Shorthand macro allows `ClaySurface(.width = w, .height = h) { children }` syntax. CEL_Clay macro stays clean (Clay's own error handler catches misuse). Header compiles without macro conflicts.
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end compile validation + phase success criteria check</name>
  <files>src/clay_layout.c</files>
  <action>
Validate the complete layout pipeline by performing a full build and verifying all connections.

**Step 1: Full build**

Run the full project build:
```bash
cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1
```

Fix any compilation errors. Common issues to watch for:
- Missing includes (ecs_world_t needs flecs.h, which should come via cels.h)
- Wrong flecs API (ecs_each_id may not exist in this flecs version -- check alternatives like ecs_query or ecs_filter)
- Component registration issues (cels_component_register signature)
- Clay v0.14 API differences (Clay_StringSlice vs Clay_String in text measurement callback)
- CEL_Composition in header causing multiple definition errors (should be fine with static functions)

**Step 2: Verify existing tests still pass**

```bash
cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_test && ./build/tests/cels_test
```

No regressions allowed.

**Step 3: Verify phase success criteria at code level**

Check each of the 5 phase success criteria from ROADMAP.md:

1. "A CEL_Clay() scope inside a composition opens an entity-backed CLAY() block and all standard Clay macros work inside it"
   - Verify: CEL_Clay macro expands to CLAY() with auto-ID. CLAY_TEXT, CLAY_ID, sizing config all work inside the block because it IS a standard CLAY() scope.
   - Code check: `grep "CEL_Clay" include/cels-clay/clay_layout.h` shows CLAY() wrapping.

2. "Parent-child entity relationships produce correctly nested CLAY() output in deterministic depth-first order"
   - Verify: clay_walk_entity is recursive, clay_walk_children uses ecs_children (creation order). Parent's layout_fn opens CLAY scope, CEL_Clay_Children walks children inside that scope.
   - Code check: `grep -n "clay_walk" src/clay_layout.c` shows recursive walk.

3. "The layout system runs at PreStore phase each frame, coordinating a single BeginLayout/EndLayout pass"
   - Verify: ClayLayoutSystem_Run calls Clay_BeginLayout/Clay_EndLayout. Registered at CELS_Phase_PreStore.
   - Code check: `grep "PreStore\|BeginLayout\|EndLayout" src/clay_layout.c`

4. "Terminal resize updates propagate to Clay_SetLayoutDimensions so layout adapts to window size changes"
   - Verify: ClayLayoutSystem_Run reads ClaySurfaceConfig (width, height) each frame and calls Clay_SetLayoutDimensions. When the app updates ClaySurface props (reactive), the config component updates, and next frame the system reads the new dimensions.
   - Code check: `grep "SetLayoutDimensions" src/clay_layout.c`

5. "Text measurement callback is registered and available for renderer backends to hook into"
   - Verify: _cel_clay_layout_init calls Clay_SetMeasureTextFunction with the cell-based measurement function.
   - Code check: `grep "SetMeasureTextFunction" src/clay_layout.c`

**Step 4: Fix any issues found**

If the build revealed issues or if any success criteria is not met at the code level, fix the relevant file (most likely clay_layout.c for flecs API issues or clay_layout.h for macro issues).

Common fixes:
- If `ecs_each_id` doesn't exist: use `ecs_query_init` / `ecs_query_each` or the flecs filter API
- If `ecs_children` doesn't exist: use `ecs_get_target` iteration or `EcsChildOf` pair iteration
- If Clay_StringSlice vs Clay_String issue: check clay.h for the exact callback typedef
- If CEL_Composition in header causes linker errors: move composition body to clay_layout.c and keep only the shorthand macro in the header

Do NOT add new features. Only fix compilation and connection issues.
  </action>
  <verify>
1. `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | grep -i error` returns nothing
2. All existing tests pass (if test target exists)
3. grep confirms: CEL_Clay wraps CLAY(), tree walk is recursive, system at PreStore, SetLayoutDimensions called, SetMeasureTextFunction called
4. No compiler warnings related to cels-clay files (clean compile)
  </verify>
  <done>
Full project compiles with zero errors. All 5 phase success criteria verified at code level: CEL_Clay wraps CLAY with auto-ID, tree walk is depth-first via ecs_children, layout system at PreStore with BeginLayout/EndLayout, ClaySurface dimensions propagate to Clay_SetLayoutDimensions, text measurement registered. Existing tests pass. No regressions.
  </done>
</task>

</tasks>

<verification>
1. ClaySurface composition exists in header and is invocable with shorthand macro
2. Full project builds with zero errors
3. All 5 phase success criteria verified at code level:
   - CEL_Clay -> CLAY() with auto-ID (success criterion 1)
   - Recursive depth-first tree walk (success criterion 2)
   - PreStore system with BeginLayout/EndLayout (success criterion 3)
   - ClaySurface dimensions -> Clay_SetLayoutDimensions (success criterion 4)
   - Text measurement callback registered (success criterion 5)
4. Existing tests pass
5. No compiler warnings from cels-clay source files
</verification>

<success_criteria>
- ClaySurface is a working built-in composition with shorthand macro
- CEL_Clay is safe (Clay error handler catches misuse, documented in header)
- Full build succeeds with zero errors
- All 5 phase success criteria from ROADMAP.md verified
- No regressions to existing tests
- Layout pipeline fully wired: Clay_Engine_use -> layout init -> system registration -> per-frame layout pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-layout-system-core/02-03-SUMMARY.md`
</output>
